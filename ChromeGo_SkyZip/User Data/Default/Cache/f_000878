<!DOCTYPE html>
<html lang="en-US" class="no-js">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<link rel="profile" href="http://gmpg.org/xfn/11">
	<link rel="pingback" href="https://systemisbusy.info/blog/xmlrpc.php">
	<!--[if lt IE 9]>
	<script src="https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/js/html5.js"></script>
	<![endif]-->
	<script>(function(html){html.className = html.className.replace(/\bno-js\b/,'js')})(document.documentElement);</script>
<title>BSoD_Ultimate, Author at System is busy.</title>

<!-- This site is optimized with the Yoast SEO plugin v12.0 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="https://systemisbusy.info/blog/author/zetapuppis/" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="BSoD_Ultimate, Author at System is busy." />
<script type='application/ld+json' class='yoast-schema-graph yoast-schema-graph--main'>{"@context":"https://schema.org","@graph":[{"@type":"WebSite","@id":"https://systemisbusy.info/blog/#website","url":"https://systemisbusy.info/blog/","name":"System is busy.","potentialAction":{"@type":"SearchAction","target":"https://systemisbusy.info/blog/?s={search_term_string}","query-input":"required name=search_term_string"}},{"@type":"ProfilePage","@id":"https://systemisbusy.info/blog/author/zetapuppis/#webpage","url":"https://systemisbusy.info/blog/author/zetapuppis/","inLanguage":"en-US","name":"BSoD_Ultimate, Author at System is busy.","isPartOf":{"@id":"https://systemisbusy.info/blog/#website"}},{"@type":["Person"],"@id":"https://systemisbusy.info/blog/#/schema/person/14d7cd49b88a74e480f1bb41b9e9986f","name":"BSoD_Ultimate","image":{"@type":"ImageObject","@id":"https://systemisbusy.info/blog/#authorlogo","url":"https://secure.gravatar.com/avatar/69560868a8dbdaff2906b2d258ef0938?s=96&d=mm&r=g","caption":"BSoD_Ultimate"},"sameAs":[],"mainEntityOfPage":{"@id":"https://systemisbusy.info/blog/author/zetapuppis/#webpage"}}]}</script>
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='//fonts.googleapis.com' />
<link rel='dns-prefetch' href='//s.w.org' />
<link href='https://fonts.gstatic.com' crossorigin rel='preconnect' />
<link rel="alternate" type="application/rss+xml" title="System is busy. &raquo; Feed" href="https://systemisbusy.info/blog/feed/" />
<link rel="alternate" type="application/rss+xml" title="System is busy. &raquo; Comments Feed" href="https://systemisbusy.info/blog/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="System is busy. &raquo; Posts by BSoD_Ultimate Feed" href="https://systemisbusy.info/blog/author/zetapuppis/feed/" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/12.0.0-1\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/12.0.0-1\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/systemisbusy.info\/blog\/wp-includes\/js\/wp-emoji-release.min.js?ver=5.2.3"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55357,56424,55356,57342,8205,55358,56605,8205,55357,56424,55356,57340],[55357,56424,55356,57342,8203,55358,56605,8203,55357,56424,55356,57340]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel='stylesheet' id='wp-block-library-css'  href='https://systemisbusy.info/blog/wp-includes/css/dist/block-library/style.min.css?ver=5.2.3' type='text/css' media='all' />
<link rel='stylesheet' id='wp-block-library-theme-css'  href='https://systemisbusy.info/blog/wp-includes/css/dist/block-library/theme.min.css?ver=5.2.3' type='text/css' media='all' />
<link rel='stylesheet' id='font-awesome-css'  href='https://systemisbusy.info/blog/wp-content/plugins/contact-widgets/assets/css/font-awesome.min.css?ver=4.7.0' type='text/css' media='all' />
<link rel='stylesheet' id='twentyfifteen-fonts-css'  href='https://fonts.googleapis.com/css?family=Noto+Sans%3A400italic%2C700italic%2C400%2C700%7CNoto+Serif%3A400italic%2C700italic%2C400%2C700%7CInconsolata%3A400%2C700&#038;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/genericons/genericons.css?ver=3.2' type='text/css' media='all' />
<link rel='stylesheet' id='twentyfifteen-style-css'  href='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/style.css?ver=5.2.3' type='text/css' media='all' />
<style id='twentyfifteen-style-inline-css' type='text/css'>

		/* Custom Sidebar Text Color */
		.site-title a,
		.site-description,
		.secondary-toggle:before {
			color: #020202;
		}

		.site-title a:hover,
		.site-title a:focus {
			color: #020202; /* Fallback for IE7 and IE8 */
			color: rgba( 2, 2, 2, 0.7);
		}

		.secondary-toggle {
			border-color: #020202; /* Fallback for IE7 and IE8 */
			border-color: rgba( 2, 2, 2, 0.1);
		}

		.secondary-toggle:hover,
		.secondary-toggle:focus {
			border-color: #020202; /* Fallback for IE7 and IE8 */
			border-color: rgba( 2, 2, 2, 0.3);
		}

		.site-title a {
			outline-color: #020202; /* Fallback for IE7 and IE8 */
			outline-color: rgba( 2, 2, 2, 0.3);
		}

		@media screen and (min-width: 59.6875em) {
			.secondary a,
			.dropdown-toggle:after,
			.widget-title,
			.widget blockquote cite,
			.widget blockquote small {
				color: #020202;
			}

			.widget button,
			.widget input[type="button"],
			.widget input[type="reset"],
			.widget input[type="submit"],
			.widget_calendar tbody a {
				background-color: #020202;
			}

			.textwidget a {
				border-color: #020202;
			}

			.secondary a:hover,
			.secondary a:focus,
			.main-navigation .menu-item-description,
			.widget,
			.widget blockquote,
			.widget .wp-caption-text,
			.widget .gallery-caption {
				color: rgba( 2, 2, 2, 0.7);
			}

			.widget button:hover,
			.widget button:focus,
			.widget input[type="button"]:hover,
			.widget input[type="button"]:focus,
			.widget input[type="reset"]:hover,
			.widget input[type="reset"]:focus,
			.widget input[type="submit"]:hover,
			.widget input[type="submit"]:focus,
			.widget_calendar tbody a:hover,
			.widget_calendar tbody a:focus {
				background-color: rgba( 2, 2, 2, 0.7);
			}

			.widget blockquote {
				border-color: rgba( 2, 2, 2, 0.7);
			}

			.main-navigation ul,
			.main-navigation li,
			.secondary-toggle,
			.widget input,
			.widget textarea,
			.widget table,
			.widget th,
			.widget td,
			.widget pre,
			.widget li,
			.widget_categories .children,
			.widget_nav_menu .sub-menu,
			.widget_pages .children,
			.widget abbr[title] {
				border-color: rgba( 2, 2, 2, 0.1);
			}

			.dropdown-toggle:hover,
			.dropdown-toggle:focus,
			.widget hr {
				background-color: rgba( 2, 2, 2, 0.1);
			}

			.widget input:focus,
			.widget textarea:focus {
				border-color: rgba( 2, 2, 2, 0.3);
			}

			.sidebar a:focus,
			.dropdown-toggle:focus {
				outline-color: rgba( 2, 2, 2, 0.3);
			}
		}
	
</style>
<link rel='stylesheet' id='twentyfifteen-block-style-css'  href='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/css/blocks.css?ver=20181018' type='text/css' media='all' />
<!--[if lt IE 9]>
<link rel='stylesheet' id='twentyfifteen-ie-css'  href='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/css/ie.css?ver=20141010' type='text/css' media='all' />
<![endif]-->
<!--[if lt IE 8]>
<link rel='stylesheet' id='twentyfifteen-ie7-css'  href='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/css/ie7.css?ver=20141010' type='text/css' media='all' />
<![endif]-->
<script type='text/javascript' src='https://systemisbusy.info/blog/wp-includes/js/jquery/jquery.js?ver=1.12.4-wp'></script>
<script type='text/javascript' src='https://systemisbusy.info/blog/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='https://systemisbusy.info/blog/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://systemisbusy.info/blog/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://systemisbusy.info/blog/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 5.2.3" />
		<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
		<style type="text/css" id="custom-background-css">
body.custom-background { background-image: url("https://systemisbusy.info/blog/wp-content/uploads/2018/12/adwaita-morning.jpg"); background-position: center top; background-size: auto; background-repeat: repeat; background-attachment: fixed; }
</style>
			<style type="text/css" id="wp-custom-css">
			/*header background*/
body::before, .site-header {
	opacity: 0.8;
}

.site-title {
	font-family: Courier New, Courier, monospace;
	font-size: 20px
}

#menu-item-182 a:before {
    content: "\f108";
}

.search-field {
	font-family: Courier New, Courier, monospace;
}

.menu-item {
	font-size: 18px;
}

.widget-title {
	font-family: Courier New, Courier, monospace;
	font-size: 18px;
}

.site-footer .site-info {
	font-family: Courier New, Courier, monospace;
}
		</style>
		</head>

<body class="archive author author-zetapuppis author-1 custom-background wp-embed-responsive">
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<div id="sidebar" class="sidebar">
		<header id="masthead" class="site-header" role="banner">
			<div class="site-branding">
										<p class="site-title"><a href="https://systemisbusy.info/blog/" rel="home">System is busy.</a></p>
									<button class="secondary-toggle">Menu and widgets</button>
			</div><!-- .site-branding -->
		</header><!-- .site-header -->

			<div id="secondary" class="secondary">

					<nav id="site-navigation" class="main-navigation" role="navigation">
				<div class="menu-main-container"><ul id="menu-main" class="nav-menu"><li id="menu-item-21" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-21"><a href="https://systemisbusy.info/blog">Home</a></li>
<li id="menu-item-144" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-144"><a href="https://systemisbusy.info/blog/about/">About me</a></li>
</ul></div>			</nav><!-- .main-navigation -->
		
					<nav id="social-navigation" class="social-navigation" role="navigation">
				<div class="menu-contact-container"><ul id="menu-contact" class="menu"><li id="menu-item-20" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-20"><a title="My Twitter account" target="_blank" rel="noopener noreferrer" href="https://twitter.com/BSoD_ultimate"><span class="screen-reader-text">Twitter</span></a></li>
<li id="menu-item-182" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-182"><a title="My Telegram channel" target="_blank" rel="noopener noreferrer" href="https://t.me/joinchat/AAAAAElzzqoZKemApnD1fw"><span class="screen-reader-text">Telegram</span></a></li>
</ul></div>			</nav><!-- .social-navigation -->
		
					<div id="widget-area" class="widget-area" role="complementary">
				<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="https://systemisbusy.info/blog/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit screen-reader-text" value="Search" />
			</form></aside>		<aside id="recent-posts-2" class="widget widget_recent_entries">		<h2 class="widget-title">Recent Posts</h2>		<ul>
											<li>
					<a href="https://systemisbusy.info/blog/2019/09/03/%e7%bb%99electron%e5%81%9ac%e5%bc%80%e5%8f%91%e7%9a%84%e9%82%a3%e4%ba%9b%e5%9d%91/">给Electron做C++开发的那些坑</a>
									</li>
											<li>
					<a href="https://systemisbusy.info/blog/2019/08/09/uv_async_t%e8%ae%a9node-js%e8%84%9a%e6%9c%ac%e5%81%9c%e6%ad%a2%e8%bf%90%e8%a1%8c/">uv_async_t让Node.js脚本停止运行</a>
									</li>
											<li>
					<a href="https://systemisbusy.info/blog/2019/01/09/%e7%bc%96%e5%86%99%e5%85%8d%e6%b3%a8%e5%86%8ccom%e7%bb%84%e4%bb%b6%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf/">编写免注册COM组件的正确姿势</a>
									</li>
											<li>
					<a href="https://systemisbusy.info/blog/2018/12/26/%e6%9c%ac%e7%ab%99%e7%8e%b0%e5%b7%b2%e6%94%af%e6%8c%81hsts-preload/">本站现已支持HSTS Preload</a>
									</li>
											<li>
					<a href="https://systemisbusy.info/blog/2018/12/25/libstdc%e7%9a%84stdregex%e7%9a%84%e4%b8%80%e4%b8%aa%e5%9d%91/">libstdc++的std::regex的一个坑</a>
									</li>
					</ul>
		</aside><aside id="recent-comments-2" class="widget widget_recent_comments"><h2 class="widget-title">Recent Comments</h2><ul id="recentcomments"></ul></aside><aside id="archives-2" class="widget widget_archive"><h2 class="widget-title">Archives</h2>		<ul>
				<li><a href='https://systemisbusy.info/blog/2019/09/'>September 2019</a></li>
	<li><a href='https://systemisbusy.info/blog/2019/08/'>August 2019</a></li>
	<li><a href='https://systemisbusy.info/blog/2019/01/'>January 2019</a></li>
	<li><a href='https://systemisbusy.info/blog/2018/12/'>December 2018</a></li>
		</ul>
			</aside><aside id="categories-2" class="widget widget_categories"><h2 class="widget-title">Categories</h2>		<ul>
				<li class="cat-item cat-item-1"><a href="https://systemisbusy.info/blog/category/uncategorized/">Uncategorized</a>
</li>
		</ul>
			</aside><!--
Plugin: Custom Meta Widget
Plugin URL: http://shinraholdings.com/plugins/custom-meta-widget/
-->
<aside id="custommetawidget-3" class="widget customMetaWidget"><h2 class="widget-title">Meta</h2>		<ul>

		
		
					<li><a href="https://systemisbusy.info/blog/feed/">Entries <abbr title="Really Simple Syndication">RSS</abbr></a></li>
		

		
			<li><a href="https://systemisbusy.info/blog/comments/feed/">Comments <abbr title="Really Simple Syndication">RSS</abbr></a></li>
		
		<li><a href="https://wordpress.org/" title="Powered by WordPress, state-of-the-art semantic personal publishing platform.">WordPress.org</a></li><li><a href="https://twitter.com/BSoD_ultimate">Twitter</a></li>		</ul>

	</aside>			</div><!-- .widget-area -->
		
	</div><!-- .secondary -->

	</div><!-- .sidebar -->

	<div id="content" class="site-content">

	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">Author: <span class="vcard">BSoD_Ultimate</span></h1>			</header><!-- .page-header -->

			
<article id="post-202" class="post-202 post type-post status-publish format-standard hentry category-uncategorized">
	
	<header class="entry-header">
		<h2 class="entry-title"><a href="https://systemisbusy.info/blog/2019/09/03/%e7%bb%99electron%e5%81%9ac%e5%bc%80%e5%8f%91%e7%9a%84%e9%82%a3%e4%ba%9b%e5%9d%91/" rel="bookmark">给Electron做C++开发的那些坑</a></h2>	</header><!-- .entry-header -->

	<div class="entry-content">
		<p>Electron这东西太火了，客户端程序全面Electron化DSSQ不可避，几乎所有新上线的客户端程序你打开安装目录都能看到熟悉的<code>app.asar</code>和<code>electron.asar</code>。在前东家干活做客户端，项目经理也执意要上Electron框架，说有那么多成功案例了，还有你看看咱公司别的项目组用Electron做的项目多漂亮，这东西一定很好用；而且你看公司这么多前端高手，你写界面多费劲啊，界面这边前端全包了就行了，你只要把后面的cpp代码维护好，给前端提供合适的API就行，你看怎么样。我的心情那是十万头羊驼呼啸而过。因为眼前的这个项目不仅仅是要用Electron，最终生成出来的程序还要在一套代码的基础上在Windows/Linux/Mac平台上全都能正常编译运行，甚至还要在某些机构因为安全可靠原因定制的Linux上跑。用Electron这就算了，这涉及到多个语言的交互，一套代码还要在三个平台上跑，Linux上甚至缺依赖，这坑不是一般的大啊！可是经理执意认为他的想法是正确的，毕竟那么多成功的案例（？），必须得走这个道路。虽然心中一万个不愿意，然而为了讨生活，只好硬着头皮按照项目经理的思路把项目推进下去。</p>
<p>最终基本达成需求的客户端是做出来了，也成功地实现了跨平台，在&#8221;安全可靠&#8221;的linux发行版上也能正常运行。客户端是在Electron框架下Web和C++代码混合的架构，Web代码负责界面展现，c++代码包揽了与服务端通信、存储本地数据的工作。做出来的成果虽然能用，但是无论是界面还是后台处理的代码，里面都有很多不尽如人意的地方，给客户展示的程序没有做到差强人意，直到我离职的时候，还有很多缺陷亟待解决。</p>
<p>同样，在开发和测试的过程中，也毫无悬念地踩了许多的坑，更发生了许多不愉快的事情。这里把当时遇到的坑和教训写下来做备忘，分享出来。</p>
<p>文章的内容都是基于自己的体验所写，随着文中涉及项目版本的迭代，事实情况可能有变化，所以仅供参考。</p>
<h2>编译你的C++插件</h2>
<p>写c和C++程序，编译是一道绕不过去的坎，所以首先来讲编译。</p>
<p>用过Electron的人应该都知道，Electron大体上是Node.js和Chromium的缝合怪。我的理解是让Node.js和Chromium共享同一个V8脚本引擎，然后再导出一些和客户端相关的API，例如操作窗口、任务栏等等，把这些都完成了，Electron这东西就做出来了。Chromium和Node.js大部分的代码都是用c++实现的，所以理所当然地也可以用C++为它们开发插件。</p>
<p>然后Electron给出的解决方案是什么呢？在Eletcron文档里搜native这个字眼，找到了这个：<a href="https://electronjs.org/docs/tutorial/using-native-node-modules">https://electronjs.org/docs/tutorial/using-native-node-modules</a>，所以Electron给的方案是，你可以写Node.js的插件为你的客户端提供后台支持，写好的Node插件构建的时候链接到Electron带的Node.js实例上，你的JS代码就能调用你用C++写的插件了。那么再看看怎样用C++给Node.js写插件吧，你就找到了这个文档：<a href="https://nodejs.org/dist/latest-v10.x/docs/api/addons.html">https://nodejs.org/dist/latest-v10.x/docs/api/addons.html</a>，它告诉你，给Node.js写C++插件需要用到node-gyp这个工具，这个工具调用的是<code>gyp</code>这个google写的构建工具来构建你的伟大的C++插件。之后你照着Node.js文档给的示例，成功写出了你的第一个Node插件；然后又照着Electron的文档把你的Node.js插件链接到了Electron上，之后又写了个HTML给Electron用，里面成功调用了你写的插件。</p>
<p>很有成就感，很轻松，是不是？先别激动，Node.js给的示例太简单，里面只寥寥几句说了gyp这个工具应该怎么用，实际的需求一定会有坑，官方文档是不可能面面俱到全部解答的。</p>
<p>就这样你开始写项目了。假如你负责的用了Electron的东西要在Windows上跑，然后你需要调用DirectShow来操作摄像头捕获自定义分辨率的图像。虽然Chromium自身就带了摄像头的支持，但是功能很有限，不能用来完成要求你去实现的需求，所以你不得不去用DirectShow（当然DirectShow过时了微软推荐用Media Foundation）。用DirectShow你必须在最终的程序里链接这两个库：<code>quartz.lib</code>和<code>Strmiids.lib</code>。怎么链接这两个静态库？Node.js没告诉你。既然如此那就去找GYP这个工具的文档吧。google第一条，<a href="https://gyp.gsrc.io">https://gyp.gsrc.io</a>，好！点开看了，你绝望地发现，google对你的疑问做出的答案是四个英文字母：TODO。玛德这文档里一坨坨的TODO和没写有什么区别吗？</p>
<p>必须要用node-gyp，还有最后一条路可走，那就是看GYP的源码找源码里的设定，但是GYP是用Python2写的，假如你不会Python那这就是个很大的困难，更何况Python2要被抛弃了。你的时间很有限的话，也不可能投入大部分精力去hack GYP这个没文档的东西。</p>
<p>绝望的你把目光投向了另一个著名的跨平台构建工具：CMake。CMake是个好东西，文档比GYP不知道强多少倍了，好多C++开源项目也在用CMake作为构建工具，这样也方便把第三方库集成进我们的项目，开心！但是还有一个问题，怎么让我们的Node插件正确地链接到Electron上？在npm库里找cmake的字眼，找到了个cmake-js模块，这个模块在介绍里把GYP毫不留情地损了一顿，然后开始推广CMake的种种好处，最后说明了下自己为帮助CMake项目链接到Node.js/Electron上做了什么样的努力，在configure你写的CMakeLists.txt时，cmake-js在CMake环境里自动帮你配置好了Node.js的头文件和链接库的全局变量，只要在CMake脚本里加上这两个环境变量就可以。看起来还不错。</p>
<p>于是你尝试用cmake-js构建你的插件，代码规模小的时候似乎还不错。代码量开始增长，需要重新组织项目结构的时候，事情突然变得微妙了起来。cmake-js把CMake的环境变量<code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>和<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>都给改写成了与<code>node-gyp</code>类似的形式，cmake-js的用意大概是想让插件直接生成到指定的目录下。但是假如你的插件项目是依赖cmake的install命令来安装，cmake-js的这个举动就会给你带来麻烦。</p>
<p>cmake-js还有个毛病，给node.exe构建c++插件的问题算是解决了，但是给electron构建插件，它用了一种丑陋的方式。要对特定的Electron版本构建插件，需要在package.json里定义一个&#8221;cmake-js&#8221;字段，里面写上node runtime的类型是electron，然后指定个版本号，这样cmake-js才能正确地构建出指定版本electron可用的二进制文件，如果你的整个项目需要更新Electron版本，你就需要同时改两个地方，有点麻烦同时又有遗漏的可能。</p>
<p>最后我参与的项目用了这样的构建路线：代码是用CMake组织起来的，因为一些库是动态链接到插件主库，需要自己来设计最终生成文件的目录结构，用到了CMake的install命令。这样node-gyp和cmake-js都不好用了。处理链接Node.js的问题时，我在CMake脚本里声明了外部变量，configure的时候必须正确指定Node.js头文件和链接库所在的路径。需要获取Node.js或者Electron的头文件和库时，node-gyp提供了<code>node-gyp install</code>命令能把指定版本的Node.js头文件和lib文件下载到在特定的目录，windows环境下保存的目录在<code>%LOCALAPPDATA%\node-gyp\Cache\&lt;版本号&gt;</code>，下载成功后就把头文件和静态库保存的目录传给CMake脚本。为Electron构建插件也是同理，只不过命令换成了<code>node-gyp install --target=4.2.9 --arch=x64 --dist-url=https://electronjs.org/headers</code>。为了方便，还写了一个JS脚本按顺序调用node-gyp和CMake把整个的构建过程封装了起来。</p>
<p>这样构建确实麻烦，但是假如你不决定把你的C++插件上传到npm库供所有人使用，这种构建方式对最终的用户没有任何影响，因为用户能接触到的只有二进制文件。</p>
<p>我的感觉是，给Node.js/Electron写C++插件，项目大到一定程度时，真正靠谱的只有自己手动处理Node.js实例的链接问题。node-gyp给开发者提供的支持太少，而cmake-js又包办了一些不该包办的东西，专门给Electron开发插件时也不那么好用。只有自己手动处理依赖才是最灵活的方式。手动解决依赖在你需要为Electron打补丁时，处理起来也最方便。</p>
<h2>在Electron环境下调试C++插件的代码</h2>
<p>用Electron写客户端，假如涉及到C/C++代码，大多数情况是写C++库的负责实现功能然后导出API，前端工程师负责实现界面，然后调用c++库导出的JS API。毕竟这就是Electron所谓的长处么，Web技术写界面厉害，效果非常绚丽，那就用Web写；C++性能高，和操作系统交互方便，有这些需求的代码用C++写。两者都能发挥自己的长处，听起来似乎非常美好。</p>
<p>然而又懂C++又懂JS框架的人凤毛麟角。所以通常情况下界面和后端肯定是要不同的人分别推进的。那么在c++这边，给JS提供的API实现好了，怎么调试代码来保证功能是正确实现的呢？这情况有点像写Web系统，只不过做Web系统给前端工程师们的东西不是一个HTTP URL，给Electron做C++插件给是给前端工程师用JavaScript能直接调用的接口。HTTP API还好说，有个Postman神器（居然也是用Electron框架做的！），用来测试HTTP接口非常好用。可是直接给JS API就没那么简单了。</p>
<p>按照Electron的思路，API实现完了，想要在Electron环境下测试API，大概流程是这样的：Electron是个GUI框架，意味着要测试接口，你得先用Electron画出个GUI出来，点界面里面的按钮来测试；具体实现是首先要写个index.js，里面让Electron创建一个浏览器窗口，之后让新建出来的浏览器窗口加载一个网页，网页里把按钮画出来，在网页附带的js脚本里再调用实现好的C++函数；之后要导出新功能的时候，继续在网页里加按钮，然后按钮调用新加的方法；每次新加功能要测试的时候都要在测试脚本（网页）里修改两个以上的地方，真的很麻烦。C++代码出错了要现场调试附加到Electron的时候，要找到已经加载C++插件的进程也很麻烦：插件是在主进程中加载时比较好办，要调试的进程就是为了测试而启动的那个进程；插件是在html中直接引用的时候，加载C++插件的Electron进程是渲染进程，这时候就麻烦了，你不得不去挨个试Electron主进程fork出来的子进程，看哪个加载了自己写的C++模块，或者Windows下去用Process Explorer去看。之后才能开展调试的工作。</p>
<p>只用c#/c++做客户端的时候，我心中理想的调试方式是在Visual Studio里面加好断点，按F5，等代码编译完，之后就可以开展调试的工作，很舒服。那么调试给Electron写的C++代码，真的就不能做到这样轻松吗？虽然是给Electron写插件，但是我们调用的都是Node.js的API，也一直是参照Node.js文档给的指导写的C++代码，所以完全可以为Node.js编译写好的C++代码嘛！给Node.js写C++插件，要测试的时候只要写好一个js测试脚本就够了。调试也简单，在vs里面把启动进程设成node.exe，然后在启动参数里启动之前写好的测试脚本，这样设置好调试选项，按F5就能直接调试C++插件。有了方便和可靠的调试方法，C++代码的大部分问题都能解决掉。</p>
<p>开发时调试代码的问题，用这种变通的方式算是圆满解决了。不过还是得研究如何在Electron环境下调试，因为与前端工程师们的代码整合的时候还是要面对Electron环境，前端在Electron环境下发现了C++代码的BUG，在Node.js环境下没发现，于是还是得去想出一种方法去调试解决它。要在前端工程师开发界面的环境下调试C++代码，由于前端配置开发环境方式多种多样，这种环境下的调试没有唯一的解决方案，不过主要的思路还是去想办法附加上正确的Electron进程，在vs的调试选项里启动electron.exe然后调试是一件不现实的事情。例如前东家的项目里用到了electron-vue，electron-vue项目启动开发模式时是用Webpack启动了一个本地Web服务器，之后启动Electron的时候是从本地Web服务器加载界面元素的，这就意味着单纯启动Electron.exe是不可能正确启动前端工程师的开发环境的。</p>
<p>假如能成功地附加到正确的进程，除了初始化相关的代码，其余的代码应该都能调试到。要调试插件初始化相关的c++代码，如果是在主进程加载c++插件，Electron提供了<code>--inspect-brk</code>启动参数，可以让程序在入口点JS之前中断运行等待调试器附加。这时候把vs调试器附加到electron.exe上，在C++的相关初始化代码处加断点，之后再让Node.js的调试器连接到<code>inspect-brk</code>参数启动的调试端口，程序就会中断在刚才加的C++断点上；如果C++插件是在渲染进程上加载的，暂时没有什么好办法。</p>
<h2>JS代码怎样引用C++插件</h2>
<p>Electron程序启动时会启动多个子进程，主进程负责管理窗口消息和处理与系统有关的界面相关的功能，渲染进程负责解析网页元素，然后将解析结果传回给主进程显示。所以要加载C++模块也存在两种可能：在主进程和渲染进程里加载。这两种加载方式各有利弊，实际用的时候都有一些坑。</p>
<p>渲染进程中引用C++插件非常容易，只要在网页加载的JS代码里直接用<code>require('plugin')</code>加载模块就行。这种方式引用C++代码的优点是效率高，网页端的JS代码能直接读取到C++代码返回的对象。还有得益于现代浏览器的多进程架构，C++代码出问题了，整个Electron进程不至于全部崩溃，只有当前网页对应的渲染进程会崩溃退出，这时主进程会收到渲染进程崩溃的通知，然后主进程可以立刻恢复崩溃的页面的显示。有利必有弊，因为每个渲染进程在同一时间内只会负责处理一个页面的显示工作，所以调用主进程的接口新建一个BrowserWindow打开新窗口时，会有一个新的渲染进程来负责新页面的显示，也就意味着在新窗口加载的页面中require C++模块相当于又加载了一次。你是没办法访问之前已经加载的那个插件的实例的。假如有要求C++模块同时只能存在一个实例，这里加载了多个实例也会导致不可预知的后果出现。另外的一个坑是JS代码这样引用插件，C++模块中不能有让JS陷入挂起状态的代码，例如C++模块导出的方法会弹出模态对话框，模态对话框会阻塞JS脚本的运行直至对话框关闭为止，渲染进程中调用这个方法会就会让页面陷入未响应的状态。C++代码中有这样的方法时，这个模块就必须在主进程中引用。</p>
<p>主进程中引用C++模块，相比在渲染进程中引用要麻烦点。首先当然是要在主进程的入口点js中require要require的模块，之后要把require的结果注册成全局变量。网页中的JS脚本要调用已经在主进程加载的模块时，用类似这样的语句：</p>
<pre><code class="">  const module = require('electron').remote.getGlobal('module');
</code></pre>
<p>之后调用module导出的方法时，调用的就都是Electron主进程中加载的C++模块，而不会在渲染进程中重新加载一遍模块。</p>
<p>在主进程中引用C++模块，能保证模块的实例只会初始化一次，所有的页面访问到的C++插件都是同一个实例。上文中提到的不能在渲染进程中引用的C++模块，在主进程中运行也是没有问题的。要调试C++代码的时候，找到正确的Electron实例也很方便。这样做也有显而易见的缺点：<code>require('electron').remote</code>引用主进程的代码逻辑是依靠进程间通讯进行的，开销比直接访问处于渲染进程中的JS对象大很多，频繁访问主进程中的对象会让程序的性能变得非常差，大部分的时间会耽误在等待主进程的IPC消息上；C++代码在主线程卡死时，Electron的所有窗口都会变成未响应状态；C++代码里面出了问题让宿主Electron进程崩溃时，这种引用方式会让整个应用程序崩溃，没有恢复的机会。所以要在主进程中引用Node.js模块时，出于性能考虑必须想办法减少渲染进程访问主进程对象的频率，对C++代码质量的要求也更严格，毕竟交给客户的产品不能频繁未响应或者崩溃退出。</p>
<p>开Electron项目的坑，具体要使用哪种引用方式，需要根据具体的情境来决定。我参与的项目最初出于保证唯一实例和调试方便的考虑，把C++模块放在了主进程加载。但是看Discord是把所有的C++模块都放到了渲染进程上去加载，有点不太明白Discord是怎么做的。后来出于进程间通讯性能太差和崩溃容易处理的考虑，一直在尝试把自己的C++代码也放到渲染进程上加载，可惜这部分工作直到离职还没做完。</p>
<h2>Electron 4.0 之前和之后</h2>
<h3>4.0前和4.0后的区别</h3>
<p>Electron版本4.0之前和之后的版本差异非常大，这里的差异指的是C++这边看到的差异。</p>
<p>Electron 4.0之前，构建代码使用的工具是和Node.js一致的GYP，就是那个用Python2写的没有文档的GYP。项目附带的Node.js是集成在版本库中的，位置在<code>vendor/node</code>下，要编译这时期的Electron代码，还需要用到GitHub团队为Electron量身定制的另外一个库：libchromiumcontent。这个库按照Chromium的Content API把Chromium浏览器封装成了库，然后Electron本身调用这个库实现对Chromium的集成。没有修改配置的情况下，编译脚本会从github上拉取这个库的编译好的二进制文件。Debug模式下libchromiumcontent是编译成动态库，Release下是编译成静态库与Electron主程序集成到一起。郁闷的是这个二进制文件不包含调试符号，导致调试Debug版的Electron的源码时，会发现找不到所有与Chromium相关的C++代码对应的符号，也就没法跟踪Chromium相关的代码。要调试Chromium的部分，就得想办法先编译出来libchromiumcontent，之后再让Electron的编译脚本用自己编译出来的libchromiumcontent。整个编译过程非常的tricky，碰到错误了还需要读懂编译用的Python2脚本然后想办法改（一般是网络错误，国内的网络环境大家都懂）。</p>
<p>再说下编译出来的程序。这时的Electron用Release配置编译出来的二进制文件大概是这样的情况：Electron主程序是动态链接C运行库的，解压后的Electron目录可以看到一堆api-ms-win-crt-xxxx.dll；Node.js库被编译成动态库文件链接到Electron主程序上；Chromium内核使用的V8脚本引擎在Node.js编译生成的动态库内，与Node.js共享同一个。整个项目在Windows下编译代码用的是MSVC，在linux和macOS下用的是clang。这时候开发C++插件实际上调用的都是Node.js的动态库导出的方法，在windows下是node.dll，linux下是libnode.so，mac下是libnode.dylib。提供的SDK这方面，用node-gyp下载过来的Electron头文件与Node.js下载过来的头文件的目录结构也不一样。构建C++代码要手工处理Node.js依赖的时候要分别处理Node.js和Electron两种情况。</p>
<p>Electron版本4.0之后，编译的工具链和最终生成的文件发生了翻天覆地的变化。最重大的变化是构建工具从GYP换成了Chromium项目正在使用的GN，理由和我当时的体验差不多：GYP没有文档、工具本身用Python2实现效率低、迁移到GN工具能更方便地跟进Chromium项目的步伐整合新版本的Chromium内核。其次是为Electron量身定制的libchromiumcontent库被废弃了，现在的编译步骤是用<code>depot_tools</code>里面的工具<code>gclient</code>先把chromium源码checkout过来，之前做了点配置让<code>gclient</code>顺带把Electron也checkout下来。之后build的时候其实build的是Chromium项目，Electron项目只是其中的一个子项目，但是之前checkout的过程中在Chromium源码里打上了Electron的私货。因为整个build的过程会直接拉取Chromium源码而不是像以前那样下载编译好的文件，所以从源码构建Electron对梯子速度和稳定性的要求变得更高了。</p>
<p>这时候构建出来的Electron程序与以前比较也是大不一样。Node.js编译成了静态库集成进了Electron主程序，Node.js的API改为由主程序导出的符号来提供。同样，主程序C运行库也改成了静态链接。从官网下载的release解压后再也看不到Universal CRT运行库和Node.js的动态库了。编译Electron使用的编译器在Windows/Mac/Linux三个平台上被统一成了Clang。至于用node-gyp下载过来的SDK，Electron提供的Node.js头文件改成了与Node.js一致的目录结构，Windows下另外提供的node.lib实际上是编译生成的electron.lib。这里有坑，后面会讲到。</p>
<p>所以如此大的变化对C++插件有什么影响呢。当时我发现的这个带来的坑都是在Windows上出现的。</p>
<h3>新版本Electron正确加载C++模块必须做的trick</h3>
<p>第一个坑是Electron的文档明确指出的，相应的文档在这里：<a href="https://electronjs.org/docs/tutorial/using-native-node-modules#a-note-about-win_delay_load_hook">https://electronjs.org/docs/tutorial/using-native-node-modules#a-note-about-win_delay_load_hook</a>。新版本把Node.js静态链接到主程序上，Node.js的API都由electron.lib来导出，为了与之前的工具链兼容，下载过来的lib文件名仍然是node.lib。但是由此带来了一个弊病，生成出来的为Electron编译的C++插件在PE导入表里依赖的不是期望的electron.exe而是node.exe。这个问题会让C++扩展无法正确被Electron加载。Electron给的解决方案是，如果C++插件是用<code>node-gyp</code>编译的，<code>binding.gyp</code>文件里必须把<code>win_delay_load_hook</code>的值设为true；如果要自己处理Node.js依赖问题（原来Electron官方也知道让C++代码链接到Electron上是一件非常tricky的事情啊！），需要保证生成C++插件的链接器做了以下命令做的事情：</p>
<pre><code class=""> link.exe /OUT:"foo.node" "...\node.lib" delayimp.lib /DELAYLOAD:node.exe /DLL
     "my_addon.obj" "win_delay_load_hook.obj"
</code></pre>
<p>简单解释下，就是要打开DLL的延迟加载功能，然后需要把node-gyp附带的一个C++源文件<code>win_delay_load_hook.cc</code>加入到编译过程中。<br />
用了CMake处理编译时，要完成这个事情，需要在CMakeLists.txt里面加上类似这样的内容：</p>
<pre><code class=""># 源文件要加上win_delay_load_hook.cc
add_library(plugin SHARED
  win_delay_load_hook.cc
)

# 添加HOST_BINARY宏定义，这个宏有什么用途后面会说
target_compile_definitions(plugin PRIVATE
  HOST_BINARY="node.exe"
)

# 链接node.lib和delayimp.lib
target_link_libraries(plugin
  node.lib
  delayimp.lib
)

# 设置链接器参数
set_target_properties(plugin PROPERTIES
  LINK_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /DELAYLOAD:node.exe"
)
</code></pre>
<p>平白无故多的宏定义是什么意思呢？来看下<code>win_delay_load_hook.cc</code>写了什么：</p>
<pre><code class="">/*
 * When this file is linked to a DLL, it sets up a delay-load hook that
 * intervenes when the DLL is trying to load the host executable
 * dynamically. Instead of trying to locate the .exe file it'll just
 * return a handle to the process image.
 *
 * This allows compiled addons to work when the host executable is renamed.
 */

#ifdef _MSC_VER

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;windows.h&gt;

#include &lt;delayimp.h&gt;
#include &lt;string.h&gt;

static FARPROC WINAPI load_exe_hook(unsigned int event, DelayLoadInfo* info) {
  HMODULE m;
  if (event != dliNotePreLoadLibrary)
    return NULL;

  if (_stricmp(info-&gt;szDll, HOST_BINARY) != 0)
    return NULL;

  m = GetModuleHandle(NULL);
  return (FARPROC) m;
}

decltype(__pfnDliNotifyHook2) __pfnDliNotifyHook2 = load_exe_hook;

#endif

</code></pre>
<p>代码的意思应该很清楚，加了延迟加载功能后，在DllMain函数执行时操作系统会通知<code>win_delay_load_hook.cc</code>里面定义的回调函数。回调函数检测到要延迟加载的DLL名字是node.exe时，会直接返回当前进程的句柄(<code>GetModuleHandle(NULL);</code>)。从而让Electron能成功地链接给node.exe的C++插件载入到内存。这里面的HOST_BINARY宏正常情况下是未定义的，所以前面的CMake脚本要加上这个宏定义。</p>
<h3>std::fstream让C++模块崩溃</h3>
<p>第二个坑是Electron静态链接Node.js和C运行库带来的副作用。静态链接Node.js使得部分不该导出的C++符号被错误地导出来，其中包括但可能不限于C++标准库相关的东西，例如<code>std::stringstream</code>和<code>std::fstream</code>。假如C++插件动态链接了C/C++运行库，在使用<code>std::fstream</code>这类C++标准库中的类时就会有很神奇的事情发生。初始化fstream的实例时，编译出来的机器指令错误地调用了electron.exe导出的<code>std::fstream</code>构造函数的实现，对文件流一番操作，准备关闭文件流时，代码又调用了动态链接的C++运行库导出的<code>std::fstream</code>析构函数的实现。因为两个C++运行库实例（electron自带的和C++插件动态链接的）使用了不同的操作系统堆，所以调用析构函数会让程序立刻Crash掉。但是很神奇的是用<code>node-gyp</code>编译的C++插件就没有这个问题，打开<code>node-gyp</code>生成的vcxproj文件，原来node-gyp编译C++插件默认用的选项是静态链接C/C++运行库，这时用的fstream就都是C++插件自带的fstream实现，也就不会因为使用的堆不同而Crash。</p>
<p>为什么Electron 4.0之前就没有这个问题？那时候Electron主程序还是动态链接C/C++运行库的，新加载的C++插件如果是动态链接C/C++运行库就会直接使用在内存里的C/C++运行库DLL实例，也不会存在操作系统堆不一致导致Crash的问题。</p>
<p>要解决这个问题倒是可以把C++插件使用的C/C++运行库也改成静态链接的，在CMake里面这样做就可以：</p>
<pre><code class="">target_compile_options(plugin PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:/MTd&gt;)
target_compile_options(plugin PRIVATE $&lt;$&lt;CONFIG:MinSizeRel&gt;:/MT&gt;)
target_compile_options(plugin PRIVATE $&lt;$&lt;CONFIG:RelWithDebInfo&gt;:/MT&gt;)
target_compile_options(plugin PRIVATE $&lt;$&lt;CONFIG:Release&gt;:/MT&gt;)
</code></pre>
<p>但是静态链接C/C++运行库还会引入其它的问题，特别是在C++插件依赖第三方库的情况下，直接修改成静态链接是有很大概率碰上链接错误的，没条件修改第三方库的链接方式那就只好凉拌了。幸运的是在Electron 4.2.x和以后的版本里这个问题被修复了<a href="https://github.com/electron/electron/pull/18281">https://github.com/electron/electron/pull/18281</a>。</p>
<p>Electron静态链接C/C++运行库还有一个小坑，之前Electron自带了C/C++运行库的DLL，于是最终生成安装程序部署安装的时候没必要安装VC++运行库。现在改成静态链接Electron就没必要自带C/C++运行库DLL了。所以假如插件是动态链接C/C++运行库，那么就必须在安装程序中去设法安装VC++2015或者2017的运行库，否则如果目标系统没有装运行库，C++插件照样会加载失败。</p>
<p>写这个文章的时候，在Electron 6.0的release notes里看到官方团队已经决定停止支持3.x版本了。所以建议是能用4.x以后的版本就用，二次开发也最好基于这之后的版本，最好是用4.2.x以后的版本，开发的坑确实少很多。</p>
<h2>与前端工程师们配合工作</h2>
<p>在Electron上开发，假如互相之间没有技术栈的交集，写cpp的和写JS的前端工程师互相沟通起来简直就是互相对牛弹琴。写cpp看不透层出不穷的前端框架，写前端的认为cpp高深莫测看不懂Node.js的C++ API。两个群体之间唯一的共同话题几乎只有cpp给Node.js提供的JavaScript形式的API。所以互相之间约定好API的声明是非常重要的事情。然而两者在这上面要担负的责任却不是对等的。</p>
<p>写C++的要负责API的实现，把API测试正确，还要处理好编译让前端工程师能顺利调用C++代码。前端们只需要拿到C++模块的二进制文件，负责调用导出的API，然后看预期结果对不对就行，前端工程师发现API的调用结果与预期不符的时候，还是会把锅甩到C++工程师头上。前端已经开始使用C++模块导出的API时，C++这边API的声明发生了与之前不兼容的变化，已有的前端代码调用就会出错。这时还得麻烦前端工程师来修改对应的调用，可是有时候时间紧急还是必须得写C++的自己去改，这就很尴尬，自己挖的坑还得自己填。种种不如意的情况都要求写C++模块的人去学习前端工程师们的使用的框架和代码，对能力的要求相对要高一些。</p>
<p>反过来前端工程师在这方面也不轻松，虽然说前端工程师需要的只是C++模块的二进制文件和API的声明，但是要看懂C++模块的编译方法以及配置好工作环境也是个不容易的事情。我参与项目的时候，几乎每新来一个前端加入开发，我就得亲自去帮忙在他的电脑上面把VC2017、Python2/3、CMake和环境变量都安装配置一遍，虽然项目的readme里面已经把环境搭建的方法写得自认为很详细了，但是在各种电脑上面还是有很多未知的坑，尤其是VC++2017的安装，几乎没有装对的，到头来我还得亲自跑腿去帮忙。为了从支持的无底洞里面解脱出来，强烈建议写C++的为C++模块配置一个持续集成环境，这样前端工程师们就不需要为编译操心了，只要从网站上下载最新的二进制文件就行，大家都轻松。</p>
<h2>结论</h2>
<p>Electron这个东西确实很优秀很强大，毕竟把Chromium和Node.js两个大坑整合到了一起，还抽象出了一组助力客户端开发的基本API，这本身就是一件了不起的事情，至少以我而言我是没有能力做这件事。抛开弊病不谈，Discord、Skype、Postman、VSCode……甚至Visual Studio安装程序都改用Electron来做界面了。那么多成功的案例摆在那里，表明这东西确实是受到大家认可的。大量的前端工程师们透过Electron这个框架进入了客户端开发的领域，为一切都可以用JavaScript实现的愿景立下了汗马功劳。所以这东西真的有那么好吗？虽然在JavaScript那边看起来很光鲜，但是客户端的逻辑很多情况下要比Web页面复杂的多，Electron更是塞了个高度复杂的Chromium内核，只用JavaScript时就已经需要弄懂Electron的进程间通讯是怎么回事。在C++代码这边，更是一个混乱邪恶的世界，把C++代码正确的链接到Electron上已经是一件tricky的工作，Electron环境和单纯的Node.js环境之间更有巨大不同，还有无数的坑等待去发掘。所以很明显Electron虽然看起来易用，但是实际上对开发者的要求非常高。个人做一些小东西可能还不错，公司真的要拿它做复杂的项目，必须得有一位懂Web前端也懂Node.js的大佬坐镇，涉及到其它语言的开发，更是需要去有人懂Chromium和Node.js的源代码或者有这个能力去攻克它们。否则这东西并不会表现的像它承诺的那样好用，碰到一些问题真的是完全没法找原因，项目也会一而再再而三的延期。</p>
<p>最后用两个自问自答来表达对Electron的看法。</p>
<p>有人要高薪找懂Electron的人来开发你愿意去吗？我的回答是愿意。谁会和钱过不去？既然踩那么多坑了，自然有经验去掌控新项目，项目的进展也可能会更快因为可能能少走很多弯路，这是件双赢的事情。</p>
<p>个人独立写小东西会首选Electron框架吗？我的回答是坚决不用。先不说两种语言交互本来就比单一语言开发要复杂这件事，单是眼花缭乱的前端框架就已经能让我崩溃了。抛开前端框架不谈，Electron这东西弄个Hello World都复杂的要命，Qt GUI的Hello World不超过20行C++代码就能解决，《Windows程序设计第五版》里面的那个Windows Hello虽然甩的概念多但是也都可以在同一个C++源文件内解决，哪个都比Electron简单。Electron对内存和硬盘空间的需求也实在是太饥渴。写客户端对界面没要求的话，我还不如用Qt或者WPF这样的框架，起码我对这些更熟悉，它们也不像Electron那样臃肿。</p>
	</div><!-- .entry-content -->

	
	<footer class="entry-footer">
		<span class="posted-on"><span class="screen-reader-text">Posted on </span><a href="https://systemisbusy.info/blog/2019/09/03/%e7%bb%99electron%e5%81%9ac%e5%bc%80%e5%8f%91%e7%9a%84%e9%82%a3%e4%ba%9b%e5%9d%91/" rel="bookmark"><time class="entry-date published updated" datetime="2019-09-03T13:42:23+00:00">September 3, 2019</time></a></span><span class="comments-link"><a href="https://systemisbusy.info/blog/2019/09/03/%e7%bb%99electron%e5%81%9ac%e5%bc%80%e5%8f%91%e7%9a%84%e9%82%a3%e4%ba%9b%e5%9d%91/#respond">Leave a comment<span class="screen-reader-text"> on 给Electron做C++开发的那些坑</span></a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-## -->

<article id="post-194" class="post-194 post type-post status-publish format-standard hentry category-uncategorized">
	
	<header class="entry-header">
		<h2 class="entry-title"><a href="https://systemisbusy.info/blog/2019/08/09/uv_async_t%e8%ae%a9node-js%e8%84%9a%e6%9c%ac%e5%81%9c%e6%ad%a2%e8%bf%90%e8%a1%8c/" rel="bookmark">uv_async_t让Node.js脚本停止运行</a></h2>	</header><!-- .entry-header -->

	<div class="entry-content">
		<p>在公司搬砖给Node.js写C++插件的时候遇到了一个BUG：在为Node.js导出的C++类中，如果存储了uv_async_t对象，会让一些Node.js的async/await操作不能正常工作。套上async/await，代码执行到C++代码通过回调函数异步返回给JS数据之后，脚本就停止工作了。</p>
<p>C++部分的代码大致是这样的：</p>
<pre><code class="">#include &lt;nan.h&gt;
#include &lt;memory&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

// simple wrapper for uv_async_t
class uvAsyncEvent
{
public:
    uvAsyncEvent(void* context, uv_async_cb callback)
    {
        m_pAsyncHandle.reset(new uv_async_t());
        m_pAsyncHandle-&gt;data = context;
        uv_async_init(uv_default_loop(), m_pAsyncHandle.get(), callback);
    }
    ~uvAsyncEvent()
    {
    }
    void* GetContext() const
    {
        return m_pAsyncHandle-&gt;data;
    }
    void Notify()
    {
        uv_async_send(m_pAsyncHandle.get());
    }

private:
    struct Deleter
    {
        void operator()(uv_async_t* asyncEvent) const
        {
            if (asyncEvent)
            {
                uv_close((uv_handle_t*)asyncEvent, Deleter::uvCloseCallback);
            }
        }

        static void uvCloseCallback(uv_handle_t* handle)
        {
            delete (uv_async_t*)handle;
        }
    };
    std::unique_ptr&lt;uv_async_t, Deleter&gt; m_pAsyncHandle;
};

// a c++ class exported to Node.js which holds uv_async_t handles
class Hang
    : public Nan::ObjectWrap
{
public:
    static NAN_MODULE_INIT(Init)
    {
        v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);
        tpl-&gt;SetClassName(Nan::New("Hang").ToLocalChecked());
        tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

        Nan::SetPrototypeMethod(tpl, "start", Start);
        Nan::SetPrototypeMethod(tpl, "stop", Stop);
        Nan::SetPrototypeMethod(tpl, "setCallback", SetCallback);

        constructor.Reset(Nan::GetFunction(tpl).ToLocalChecked());

        Nan::Set(target, Nan::New("Hang").ToLocalChecked(), Nan::GetFunction(tpl).ToLocalChecked());
    }

private:
    Hang()
        : m_pEvent(std::make_unique&lt;uvAsyncEvent&gt;(this, asyncCallback)) // async/await hangs
        , m_bRunning(true)
    {
    }
public:
    ~Hang()
    {
    }

    static NAN_METHOD(New)
    {
        if (info.IsConstructCall()) {
            // Invoked as constructor: `new Hang(...)`
            Hang* obj = new Hang();
            obj-&gt;Wrap(info.This());

            info.GetReturnValue().Set(info.This());

            v8::Local&lt;v8::Object&gt; context = v8::Local&lt;v8::Object&gt;::Cast(info[0]);
        }
        else {
            // Invoked as plain function `Hang(...)`, turn into construct call.
            const int argc = 1;
            v8::Local&lt;v8::Value&gt; argv[argc] = { info[0] };
            v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor);
            v8::Local&lt;v8::Object&gt; result =
                Nan::NewInstance(cons, argc, argv).ToLocalChecked();
            info.GetReturnValue().Set(result);
        }
    }

    static NAN_METHOD(SetCallback)
    {
        Hang* obj = ObjectWrap::Unwrap&lt;Hang&gt;(info.Holder());

        if (!info[0]-&gt;IsFunction())
        {
            Nan::ThrowTypeError("arg 1 is not function");
            return;
        }

        obj-&gt;m_evCallback.reset(new Nan::Callback(info[0].As&lt;v8::Function&gt;()));
    }

    static NAN_METHOD(Start)
    {
        Hang* obj = ObjectWrap::Unwrap&lt;Hang&gt;(info.Holder());

        obj-&gt;m_bRunning = true;

        struct ThreadRunner
        {
            ThreadRunner(Hang&amp; h)
                : m_obj(h)
            {
            }

            // Run
            void operator()()
            {
                while (m_obj.m_bRunning) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                    m_obj.m_pEvent-&gt;Notify();
                }
            }
        private:
            Hang&amp; m_obj;
        };

        if (!obj-&gt;m_workThread)
        {
            obj-&gt;m_workThread = std::make_unique&lt;std::thread&gt;(ThreadRunner(*obj));
        }

    }

    static NAN_METHOD(Stop)
    {
        Hang* obj = ObjectWrap::Unwrap&lt;Hang&gt;(info.Holder());

        obj-&gt;m_bRunning = false;
        if (obj-&gt;m_workThread)
        {
            obj-&gt;m_workThread-&gt;join();
            obj-&gt;m_workThread.reset();
        }

        obj-&gt;m_pEvent.reset();
    }

private:
    static void asyncCallback(uv_async_t* handle)
    {
        Hang* pThis = (Hang*)handle-&gt;data;
        Nan::HandleScope scope;

        auto ret = Nan::New("async callback").ToLocalChecked();

        v8::Local&lt;v8::Value&gt; argv[] = { ret };

        Nan::Call(*pThis-&gt;m_evCallback, 1, argv);

    }

private:
    std::unique_ptr&lt;uvAsyncEvent&gt; m_pEvent;
    std::unique_ptr&lt;Nan::Callback&gt; m_evCallback;

    std::unique_ptr&lt;std::thread&gt; m_workThread;
    bool m_bRunning;

private:
    static Nan::Persistent&lt;v8::Function&gt; constructor;
};
Nan::Persistent&lt;v8::Function&gt; Hang::constructor;

// an asynchronous function for test
NAN_METHOD(testAsync)
{
    class Worker : public Nan::AsyncWorker
    {
    public:
        Worker(Nan::Callback* callbk)
            : Nan::AsyncWorker(callbk)
        {
        }

        void Execute() override
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        void HandleOKCallback() override
        {
            Nan::HandleScope scope;

            int argc = 1;
            std::unique_ptr&lt;v8::Local&lt;v8::Value&gt;[]&gt; argv(new v8::Local&lt;v8::Value&gt;[argc]());

            argv[0] = Nan::New("async task result").ToLocalChecked();

            Nan::Call(*callback, argc, argv.get());
        }
    };

    Nan::Callback* callbk = new Nan::Callback(Nan::To&lt;v8::Function&gt;(info[0]).ToLocalChecked());

    Worker* pWorker = new Worker(callbk);
    Nan::AsyncQueueWorker(pWorker);
}

NAN_MODULE_INIT(InitAll) 
{
    Hang::Init(target);
    Nan::SetMethod(target, "testAsync", testAsync);
}

NODE_MODULE(hang, InitAll)

</code></pre>
<p>用来测试的脚本：</p>
<pre><code class="">const { Hang, testAsync } = require('./build/Release/hang');
const { EventEmitter } = require('events');

let h = new Hang();

// calling start method or not does not affect the problem
// h.start();

function doTestAsync() {
  return new Promise((resolve, reject) =&gt; {
    testAsync((data) =&gt; {
      // This line of code got executed without any problems
      // after 100ms of the function call(according to the C++ code)
      console.log(data);
      resolve(data);
    });
  });
}

function doSetTimeoutAsync() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      let data = 'timeout async';
      console.log(data);
      resolve(data);
    }, 100)
  });
}

// this is ok
//testAsync((data) =&gt; {
//    console.log(data);
//});

async function testHang() {
  let asyncRet = await doSetTimeoutAsync();

  // no problem
  console.log("after async call1");
  let asyncRet2 = await doTestAsync();

  // async/await operation blocks due to the creation of "hang"
  // I paused the execution via the debugger, then continue, 
  // Dramatically this line gets executed
  console.log("after async call2");
  let asyncRet3 = await doTestAsync();
  console.log("after async call3");
  let asyncRet4 = await doTestAsync();
  console.log("after async call4");

  h.stop();
}


testHang();

</code></pre>
<h2>背景和BUG表现</h2>
<p>公司搬砖的项目里，要建立一个TCP长连接，用于与服务端之间通信和保持在线状态。通常情况下会单独启动一个线程用来维护连接，现在要把从服务端接收到的数据传给JS，一个很明显的思路是在工作线程里调用<code>uv_async_send</code>来通知主线程（能调用V8的API的线程）有数据传过来。</p>
<p>代码本身是简化后的模型。C++模块导出了一个<code>Hang</code>类和一个<code>testAsync</code>函数，<code>Hang</code>类对应的C++类管理了一个<code>uv_async_t</code>对象，<code>testAsync</code>函数使用了<code>Nan::AsyncWorker</code>用于测试Node.js的异步调用。</p>
<p>发生的问题是：直接通过命令行运行脚本，测试脚本会卡在调用<code>doTestAsync</code>之后，<code>after async call2</code>不会被输出出来。在vscode中启用调试模式时得到的结果也一样。程序的输出是这样的：</p>
<pre><code class="">timeout async
after async call1
async task result
</code></pre>
<p>诡异的是，在vscode中把脚本暂停，脚本成功中断在了Node.js内部的代码里，然后继续运行，后面的输出居然输出了出来。然后脚本继续卡在第二次调用<code>doTestAsync</code>之后。如此暂停和继续运行，测试脚本居然能一路跑下去。</p>
<p>如果把断点停在<code>testAsync</code>提供的回调函数里，会发现程序走过<code>resolve(data)</code>之后就不能继续运行了。</p>
<p>把脚本本身改写成回调金字塔的样式，就像下面的代码一样，也是没有问题的。但是这样真的是太丑了，而且async/await是官方推崇的方式，总算能彻底解决回调金字塔地狱的问题，因为出现了这状况丫的还得改回去……</p>
<pre><code class="">testAsync((data) =&gt; {
  console.log(data);
  console.log("after async call2");
  testAsync((data) =&gt; {
    console.log(data);
    console.log("after async call3");
    testAsync((data) =&gt; {
      console.log(data);
      console.log("after async call4");
    });
  });
});
</code></pre>
<h2>尝试解决</h2>
<p>首先用二分法找问题原因，逐个排查最近的修改，发现去掉了创建<code>uv_async_t</code>对象的代码，这个问题就不再出现了。</p>
<p>于是整理了下代码，写了个最小的可以必现这个问题的示例。信心满满地向Node.js提交了个issue，然后这个issue一小时后被项目管理者打入了nodejs/help的冷宫，而且没人回答我提出的问题。</p>
<p>既然没有人愿意回答我的问题，那就自己干！</p>
<p>不管怎么说先build个Debug版本的Node.js程序，Release版本经过优化，找错没有那么容易。签出代码库，按照vcbuild.bat的指示来构建，好了，Debug版的Node.js程序有了。因为ABI的问题，又手动建了个vcxproj项目把刚才的c++代码链接到了debug版生成出来的node.lib上。</p>
<p>然后开始调试。先找下<code>Promise</code>是在哪里实现的，Node.js中用JS写的实现都是放在<code>lib</code>目录下。在这个目录下搜索Promise字样，无果。然后在C++代码里继续搜，发现<code>v8.h</code>中声明了一个<code>Promise</code>类。Promise类里面声明了个Resolve方法。于是抱着试试看的心态在这个方法的实现（在<code>deps/v8/src/api.cc</code>）里加了断点。然后在vs的调试选项里面让Debug版的Node.js进程执行我们的测试脚本，脚本照样还是卡住了，api.cc里面的断点没有进去，看来找的Promise的实现的位置不对。</p>
<p>继续找Promise的实现，看到Promise类的声明里有个PromiseState枚举类型，应该是用来表示Promise对象当前的状态的，心想v8脚本引擎的内外应该都用同一种类型，用&#8221;查找所有引用&#8221;找了一下，原来v8脚本引擎内部还有个v8::internal::JSPromise类（在<code>deps/v8/src/objects/js-promise.h</code>里）。F12进去，看到了这样的代码，在<code>deps/v8/src/objects.cc</code>里面，这个应该是我们要找的Promise.resolve的实现了：</p>
<pre><code class="">Handle&lt;Object&gt; JSPromise::Fulfill(Handle&lt;JSPromise&gt; promise,
                                  Handle&lt;Object&gt; value) {
  ...
  // 6. Set promise.[[PromiseState]] to "fulfilled".
  promise-&gt;set_status(Promise::kFulfilled);

  // 7. Return TriggerPromiseReactions(reactions, value).
  return TriggerPromiseReactions(isolate, reactions, value,
                                 PromiseReaction::kFulfill);
}

// static
MaybeHandle&lt;Object&gt; JSPromise::Resolve(Handle&lt;JSPromise&gt; promise,
                                       Handle&lt;Object&gt; resolution) {
  Isolate* const isolate = promise-&gt;GetIsolate();

  isolate-&gt;RunPromiseHook(PromiseHookType::kResolve, promise,
                          isolate-&gt;factory()-&gt;undefined_value());

  ...

  // 7. If Type(resolution) is not Object, then
  if (!resolution-&gt;IsJSReceiver()) {
    // a. Return FulfillPromise(promise, resolution).
    return Fulfill(promise, resolution);
  }

  ...

  // 10. Let thenAction be then.[[Value]].
  // 11. If IsCallable(thenAction) is false, then
  if (!then_action-&gt;IsCallable()) {
    // a. Return FulfillPromise(promise, resolution).
    return Fulfill(promise, resolution);
  }

  // 12. Perform EnqueueJob("PromiseJobs", PromiseResolveThenableJob,
  //                        «promise, resolution, thenAction»).
  Handle&lt;PromiseResolveThenableJobTask&gt; task =
      isolate-&gt;factory()-&gt;NewPromiseResolveThenableJobTask(
          promise, Handle&lt;JSReceiver&gt;::cast(then_action),
          Handle&lt;JSReceiver&gt;::cast(resolution), isolate-&gt;native_context());
  if (isolate-&gt;debug()-&gt;is_active() &amp;&amp; resolution-&gt;IsJSPromise()) {
    // Mark the dependency of the new {promise} on the {resolution}.
    Object::SetProperty(resolution,
                        isolate-&gt;factory()-&gt;promise_handled_by_symbol(),
                        promise, LanguageMode::kStrict)
        .Check();
  }
  isolate-&gt;EnqueueMicrotask(task);

  // 13. Return undefined.
  return isolate-&gt;factory()-&gt;undefined_value();
}
</code></pre>
<p>在这个函数里加了断点，重新调试。发现在程序卡住之前，Node.js居然没有在<code>JSPromise</code>这里中断！甚至在<code>after async call1</code>输出之前，Node.js进程也没中断在刚才在<code>objects.cc</code>中加的断点上。</p>
<p>如果换一种调用JS脚本的方式：在shell模式下运行Node.js，输入命令<code>require('./hang.js')</code>调用脚本，在<code>JSPromise</code>里加的断点生效了，但是程序之后卡住的时候，仍然没进到加的断点上。</p>
<p>两种运行脚本的方式得到不同结果的原因，大概是在命令参数里直接运行脚本的时候，Node.js把脚本的JS代码包括Promise操作全都JIT掉了，JSPromise里面的那些代码根本没有用。</p>
<p>看来这个问题和Promise的实现是没有关系的。至于还有什么其它原因实在是百思不得其解。</p>
<h2>转机</h2>
<h3>问题解决</h3>
<p>这个问题拖了将近一周的时间，直到有一天想这个问题的时候拖了下控制台窗口，改变了下Node.js控制台窗口的大小。改变了窗口大小之后，await后面的语句居然被执行了！</p>
<p>期待的结果出现了，赶紧分析下到底发生了什么让结果是对的。再次打开Node.js项目里编译生成的node.sln，用我们的debug版的Node.js启动测试脚本，脚本毫无悬念地卡死。这时候在VS调试器里暂停node.exe的运行，看到主线程中断在了下面的位置：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/08/QQ截图20190808223410.png" alt="" /><br />
可以看到Node.js调用了Windows的IOCP。一直等待的情况下，只有IOCP管理的HANDLE对应的IO操作完成或者用<code>PostQueuedCompletionStatus</code>直接向IOCP对象发消息，IOCP的等待操作才会退出。再看一下node.exe调用<code>GetQueuedCompletionStatusEx</code>传进去的超时时间是多少，现在这个状态下这个值是-1。所以说程序卡死的原因是一直在等待一个IOCP事件传过来。然而尝试修改前面的timeout数值，改成不是一直等待，重新编译代码，卡死的问题仍然存在。</p>
<p>在<code>GetQueuedCompletionStatusEx</code>的下一行加个断点，然后让node.exe继续跑下去。这之后拖一下控制台窗口，继续单步跟下去，可以看到IOCP消息对应的libuv消息（uv_req_t）类型是UV_SIGNAL_REQ。继续跟到循环结束走到下一轮循环，单步调试到uv_process_signal_req的时候（在uv_process_reqs里面），可以看到信号的编号是28。编号为28的信号是什么信号？查了下是<code>SIGWINCH</code>，在控制台窗口大小发生改变时，操作系统会向对应的进程发送这个信号。不管这么多，继续单步调试跑到下面<code>signal_wrap.cc</code>的代码时，代码走过<code>wrap-&gt;MakeCallback</code>这一行之后，await后面的JS代码要输出的东西输出到了屏幕上。</p>
<pre><code class="">  static void OnSignal(uv_signal_t* handle, int signum) {
    SignalWrap* wrap = ContainerOf(&amp;SignalWrap::handle_, handle);
    Environment* env = wrap-&gt;env();
    HandleScope handle_scope(env-&gt;isolate());
    Context::Scope context_scope(env-&gt;context());

    Local&lt;Value&gt; arg = Integer::New(env-&gt;isolate(), signum);
    wrap-&gt;MakeCallback(env-&gt;onsignal_string(), 1, &amp;arg);
  }
</code></pre>
<p>所以这个MakeCallback到底做了什么？看代码可以知道<code>SignalWrap</code>也是向JS环境导出的一个类，在JS端的名字叫<code>Signal</code>。在node项目的lib目录下狂搜，找到了与SIGWINCH信号相关的几个处理函数，但是这些函数和执行当前要继续执行的JS代码都没有任何关系。所以可能是C++代码的问题？<br />
换一种思路来找代码能正常运行的原因。既然控制台都有输出，在Windows下向控制台窗口输出，最终都会调用<code>kernel32.dll</code>导出的<code>WriteConsole</code>函数。又因为涉及到字符串的函数Windows都会提供分别处理<code>char*</code>和<code>wchar_t*</code>的两种函数，所以需要加两个断点，按Ctrl+B打开添加断点窗口，手动加上这两个断点：</p>
<pre><code class="">  {,,kernel32.dll}WriteConsoleA
  {,,kernel32.dll}WriteConsoleW
</code></pre>
<p>在启用这两个断点调试的情况下去单步调试MakeCallback方法的实现，最终锁定到了这一行C++代码：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/08/QQ截图20190809085439.png" alt="" /><br />
代码中断在<code>env_-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()</code>这一行时，让代码继续运行，node进程就会立刻中断在<code>kernel32.dll</code>导出的<code>WriteConsoleW</code>函数上。看函数的名字tick_callback_function，这个应该就是用来执行等待运行的JS代码的相关的函数，也就是测试脚本里await之后的部分。</p>
<p>所以结论是：拖动控制台窗口能让async/await继续运行，完全是个副作用。原因只不过是Node.js要运行操作系统信号相关的处理函数的时候，顺带会把等待执行的JS代码拎过来也执行一下而已。鬼使神差地就让脚本按预期的方式工作了。至于为什么新建uv_async_t对象就会让Node.js陷入无限等待IOCP消息的状态，这个我实在是无力去追查。</p>
<h3><code>SIGWINCH</code>信号是如何在windows下模拟出来的</h3>
<p>Windows本身是不支持<code>SIGWINCH</code>信号的，Node.js(libuv)用启动监听线程监听控制台窗口大小变化的方法模拟了这个信号。窗口大小变化的消息本身是用<code>PostQueuedCompletionStatus</code>直接向主线程IOCP发消息发过去的。要验证可以Ctrl+B手动加个断点<code>{,,kernelbase.dll}PostQueuedCompletionStatus</code>，然后拖动控制台窗口，程序就会中断在监听控制台窗口的线程里面。</p>
<h2>解决办法</h2>
<p>既然系统向Node.js进程发送<code>SIGWINCH</code>信号会迫使Node.js去运行下个事件循环需要执行的JS代码，那么解决方法也就出来了。</p>
<p>方法是：在测试脚本前面加个定时器，向当前Node.js进程不停地发送<code>SIGWINCH</code>信号，脚本就能继续跑下去直到结束：</p>
<pre><code class="language-Javascript ">setInterval(() =&gt; {
    process.emit('SIGWINCH');
}, 100);
</code></pre>
<p>这个解决方法实在是过于草生（中日双语），我始终认为这是Node.js的BUG，应该在事件循环处于空闲的状态时就去处理等待执行的JS代码，然而官方不理，当然原因也可能是真的不好处理。</p>
<h2>感想</h2>
<ul>
<li>二分法找BUG万岁。</li>
<li>带JIT的脚本引擎找问题是真难，因为JIT出来的汇编代码产出的调用堆栈和编译器生成出来的约定不一样。然后你就没办法看到调用JIT代码之前的堆栈发生了什么。</li>
<li>有些固有的BUG估计是没有人会理的，久而久之估计就成了feature。</li>
</ul>
<h2>后续</h2>
<p>Node.js 8.x 10.x 12.x 在Windows/Linux上都有这个问题，Mac没条件试。</p>
	</div><!-- .entry-content -->

	
	<footer class="entry-footer">
		<span class="posted-on"><span class="screen-reader-text">Posted on </span><a href="https://systemisbusy.info/blog/2019/08/09/uv_async_t%e8%ae%a9node-js%e8%84%9a%e6%9c%ac%e5%81%9c%e6%ad%a2%e8%bf%90%e8%a1%8c/" rel="bookmark"><time class="entry-date published updated" datetime="2019-08-09T02:41:27+00:00">August 9, 2019</time></a></span><span class="comments-link"><a href="https://systemisbusy.info/blog/2019/08/09/uv_async_t%e8%ae%a9node-js%e8%84%9a%e6%9c%ac%e5%81%9c%e6%ad%a2%e8%bf%90%e8%a1%8c/#respond">Leave a comment<span class="screen-reader-text"> on uv_async_t让Node.js脚本停止运行</span></a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-## -->

<article id="post-149" class="post-149 post type-post status-publish format-standard hentry category-uncategorized">
	
	<header class="entry-header">
		<h2 class="entry-title"><a href="https://systemisbusy.info/blog/2019/01/09/%e7%bc%96%e5%86%99%e5%85%8d%e6%b3%a8%e5%86%8ccom%e7%bb%84%e4%bb%b6%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf/" rel="bookmark">编写免注册COM组件的正确姿势</a></h2>	</header><!-- .entry-header -->

	<div class="entry-content">
		<p><strong>注意：此文假定你对Windows编程和微软的COM(Component Object Model组件对象模型)技术有基本的了解。并且知道ATL(Active Template Library)这个简化COM组件编写工作的库。</strong></p>
<p>这里记录折腾免注册COM组件碰到的坑作为备忘。</p>
<p>COM技术是微软发布的一套应用程序二进制接口的规范。用COM的规范导出DLL文件想要提供的API，可以保证发布出去的新版本DLL在应用程序二进制接口(ABI)上与旧版本保持一致。所以windows下要做一套提供可升级的API的动态库，COM是个很不错的选择。<strong>但是微软开的脑洞实在是太大了，它想这个二进制兼容的接口规范实现系统级的共享。</strong>这意味着一般情况下要成功创建一个COM对象，首先这个COM组件要在注册表里注册，我们才能用<code>CoCreateInstance</code>函数正确创建出来这个对象。</p>
<p>这很不绿色很不环保！！首先把放COM对象的dll删了，注册表里还有残留痕迹。其次，注册了之后这个dll的位置不能变，DLL的位置改了之后还得重新注册。这些COM组件的注册数据放在哪里，可以随便点开一个注册表中路径是<code>HKEY_CLASSES_ROOT\CLSID\{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}</code>的项，能看到每个COM组件库的CLSID和都是和DLL绝对路径绑定在一起的。这些特性对绿色程序来说是不可接受的。</p>
<p>好在Windows XP之后微软引入了免注册COM组件的概念，但是相关的文档却很难找，google了registration-free COM关键字只找到了微软让你在DLL中嵌入Manifest文件的办法，或者通篇都在谈.NET和VB怎么弄，完全没有用c艹和ATL怎样操作的指南。我试了，照那个文档里说的<strong>仅仅把普通的manifest文件编译到DLL中是不够的。</strong>用google各种找文章在一篇博客的指引下终于找到了官方手把手教你编写免注册COM组件的文章：<br />
<a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms973913(v=msdn.10)#rfacomwalk_topic6">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms973913(v=msdn.10)#rfacomwalk_topic6</a></p>
<p>照文档做的时候踩了不少坑，这里把正确的方法记录下来。</p>
<p>首先在Visual Studio下新建个c++控制台应用程序，然后再新建个用ATL的DLL，用VS提供的ATL模板在ATL工程里创建两个COM对象。然后在idl文件中给两个对象对应的接口分别添加一个方法。假设这之后ATL DLL项目包含的idl文件内容如下：</p>
<pre><code class="">// RegFreeComLib.idl : IDL source for RegFreeComLib
//

// This file will be processed by the MIDL tool to
// produce the type library (RegFreeComLib.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

[
    object,
    uuid(e237510b-fce2-48f1-ac00-e29b28ec0ddd),
    pointer_default(unique)
]
interface ITestObj1 : IUnknown
{
    [id(0), helpstring("returns \"Foo\"")] HRESULT Foo(BSTR* pVal);
};
[
    object,
    uuid(1f696df2-9532-4234-89af-1afacdc558bc),
    pointer_default(unique)
]
interface ITestObj2 : IUnknown
{
    [id(0), helpstring("return \"Bar\"")] HRESULT Bar(BSTR* pVal);
};
[
    uuid(fe8885f8-5ffb-4bdf-b738-0642d17d02a5),
    version(1.0),
]
library RegFreeComLibLib
{
    importlib("stdole2.tlb");
    [
        uuid(a75c6fc7-6656-424e-b007-b65553a45b30)
    ]
    coclass TestObj1
    {
        [default] interface ITestObj1;
    };
    [
        uuid(89c74fb1-dbb5-4b70-a48e-4706f6e3cd74)
    ]
    coclass TestObj2
    {
        [default] interface ITestObj2;
    };
};

import "shobjidl.idl";

</code></pre>
<p><code>ITestObj1::Foo</code>会返回字符串值<code>Foo</code>，<code>ITestObj2::Bar</code>会返回字符串值<code>Bar</code>。</p>
<p>之后我们要调用<code>CoCreateInstance</code>创建这两个COM对象，在主程序中写下如下代码：</p>
<pre><code class="">#include &lt;iostream&gt;

#include "RegFreeComLib_i.h"

#include &lt;atlbase.h&gt;
#include &lt;atlcom.h&gt;
#include &lt;windows.h&gt;

int main()
{
    CoInitialize(NULL);

    // 这里要包起来，否则CoUnInitialize执行之后CComPtr指向的COM对象所属的DLL早已被卸载了，程序会崩溃
    {
        HRESULT hr = S_OK;
        ATL::CComPtr&lt;ITestObj1&gt; pTestObj1;
        // 查找已注册的COM组件中是否有类TestObj1的clsid，接口的guid是ITestObj1的guid，
        // 如果有就能成功创建这个COM对象，对象的指针存放在pTestObj1中
        hr = CoCreateInstance(__uuidof(TestObj1), NULL, CLSCTX_ALL, __uuidof(ITestObj1), (void**)&amp;pTestObj1);

        ATL::CComPtr&lt;ITestObj2&gt; pTestObj2;
        hr = CoCreateInstance(__uuidof(TestObj2), NULL, CLSCTX_ALL, __uuidof(ITestObj2), (void**)&amp;pTestObj2);

        if (pTestObj1 &amp;&amp; pTestObj2)
        {
            ATL::CComBSTR str1;
            pTestObj1-&gt;Foo(&amp;str1);
            ATL::CComBSTR str2;
            pTestObj2-&gt;Bar(&amp;str2);
            // COM对象使用的字符串类型都是wchar_t的
            std::wcout &lt;&lt; str1.m_str &lt;&lt; ' ' &lt;&lt; str2.m_str &lt;&lt; std::endl;
        }
    }

    CoUninitialize();
}
</code></pre>
<p>编译，运行。记得把ATL DLL项目的生成后注册组件的选项关掉（Linker -> General -> Register Output设成false），否则运行regsvr32注册失败算编译失败。<br />
因为编译好的ATL DLL还没有在注册表中登记，所以创建COM组件的操作一定会失败。</p>
<p>要把我们编写的dll变成免注册的COM组件，需要在应用程序附带的清单文件上做手脚，把我们编写的COM对象在DLL包含的Manifest文件中声明出来。在dll工程下新建一个Manifest文件，参照IDL文件写入以下内容：</p>
<pre><code class="">&lt;?xml version='1.0' encoding='UTF-8' standalone='yes'?&gt;
&lt;assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'&gt;
  &lt;!--如果Manifest文件要嵌入到DLL中，那么name的值必须是文件名--&gt;
  &lt;!--版本号必须是mmmmm.nnnnn.ooooo.ppppp的格式--&gt;
  &lt;assemblyIdentity type="win32" name="RegFreeComLib" version="1.0.0.0" /&gt;
  &lt;!--必须与DLL文件名（包含扩展名）保持一致--&gt;
  &lt;file name = "RegFreeComLib.dll"&gt;
    &lt;!--CLSID_TestObj1--&gt;
    &lt;comClass clsid="{a75c6fc7-6656-424e-b007-b65553a45b30}" threadingModel="Apartment" /&gt;
    &lt;!--CLSID_TestObj2--&gt;
    &lt;comClass clsid="{89c74fb1-dbb5-4b70-a48e-4706f6e3cd74}" threadingModel="Apartment" /&gt;

    &lt;typelib tlbid="{fe8885f8-5ffb-4bdf-b738-0642d17d02a5}" version="1.0" helpdir=""/&gt;
  &lt;/file&gt;

  &lt;!--原教程里的这个没有看懂是什么意思，但是删掉之后免注册的机制也能正常工作--&gt;
  &lt;!--&lt;comInterfaceExternalProxyStub
      name="ISideBySideClass"
      iid="{[IID_ISideBySideClass]}"
      proxyStubClsid32="{00020424-0000-0000-C000-000000000046}"
      baseInterface="{00000000-0000-0000-C000-000000000046}"
      tlbid = "{[LIBID_SideBySide]}" /&gt;--&gt;
&lt;/assembly&gt;
</code></pre>
<p>我们的主程序要引用这些免注册COM组件，也要为主程序指定一个Manifest文件：</p>
<pre><code class="">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1"
  manifestVersion="1.0"&gt;
  &lt;dependency&gt;
    &lt;!--文件名和版本号要和刚才的COM dll包含的Manifest文件中的assemblyIdentity声明保持一致--&gt;
    &lt;dependentAssembly&gt;
      &lt;assemblyIdentity type="win32" name="RegFreeComLib" version="1.0.0.0" /&gt;
    &lt;/dependentAssembly&gt;
  &lt;/dependency&gt;
&lt;/assembly&gt;
</code></pre>
<p>然后要把编写好的清单文件嵌入到exe和dll中：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/01/SMXZMI4U4UH4VB330.jpg" alt="" /></p>
<p>按F5运行之后竟然提示了这个，WTF？？？<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/01/IJYZG@9Z5DS54_YINC_W.png" alt="" /></p>
<p>事件查看器可以帮助我们排错。开始菜单 -> 运行 输入<code>eventvwr</code>，打开事件查看器。在<code>Windows日志 -&gt; 应用程序</code>栏中能看到刚才程序启动出错的信息。这里看到错误提示是免注册COM dll附带的清单文件中不允许出现<code>requestedPrivileges</code>这个节。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/01/QQ截图20190110000125.png" alt="" /><br />
用Resource Hacker打开生成的DLL，看到生成出的Manifest文件确实是带了不该带的东西。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/01/QQ截图20190110000557.png" alt="" /><br />
解决办法是在DLL的项目属性中关掉生成Manifest文件时指定UAC操作的选项，打开 项目属性 -> 链接器 -> 清单文件，把 启用UAC 这个选项设成 否。在此要吐槽VS把一些选项藏得太深了，不好找，有的甚至要翻vcxproj才能找到设置。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2019/01/QQ截图20190110000945.png" alt="" /></p>
<p>再编译运行，就能看到程序正确输出了<code>Foo Bar</code>，证明程序成功调用了免注册的COM组件。</p>
<h3><em>附注</em></h3>
<ul>
<li>QQ的windows客户端大量应用了COM技术。用PE查看器打开QQ安装目录下的DLL文件，能看到大多数DLL都只有四个导出函数：<code>DLLRegisterServer</code>,<code>DLLUnRegisterServer</code>,<code>DLLGetClassObject</code>,<code>DLLCanUnloadNow</code>。但是奇怪的是资源区段里面的Manifest并没有像文中这样导出接口。我这里不负责任地猜测QQ客户端应该是在内部模拟了windows加载COM组件的流程，大致应该和<a href="https://www.codeproject.com/Tips/1037909/%2FTips%2F1037909%2FUsing-COM-Without-Registration">这里</a>描述的方法差不多。</li>
<li>ABI不兼容会造成什么后果，可以见这两篇文章。虽然我不同意第二篇文章说微软COM是反面教材的看法。
<ul>
<li><em><a href="https://blog.csdn.net/lightlater/article/details/16851181">https://blog.csdn.net/lightlater/article/details/16851181</a></em></li>
<li><em><a href="https://www.cnblogs.com/Solstice/archive/2011/03/09/1978024.html">https://www.cnblogs.com/Solstice/archive/2011/03/09/1978024.html</a></em></li>
</ul>
</li>
<li>因为ABI的差异，很多用C艹实现的项目要做一些额外的工作。比如说Qt的安装包里要提供通过用多种编译器编译好的Qt动态库（vc2015/vc2017/mingw64），不同编译器编译出来的Qt DLL不能混用；windows下给Node.js写原生动态库，编译好的库要链接上指定版本Node.js对应的.lib文件，在JS里面require了版本不同的原生库，就会提示<code>was compiled against a different Node.js version</code>不让你加载这个模块。</li>
</ul>
	</div><!-- .entry-content -->

	
	<footer class="entry-footer">
		<span class="posted-on"><span class="screen-reader-text">Posted on </span><a href="https://systemisbusy.info/blog/2019/01/09/%e7%bc%96%e5%86%99%e5%85%8d%e6%b3%a8%e5%86%8ccom%e7%bb%84%e4%bb%b6%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf/" rel="bookmark"><time class="entry-date published" datetime="2019-01-09T16:25:06+00:00">January 9, 2019</time><time class="updated" datetime="2019-01-09T16:44:18+00:00">January 9, 2019</time></a></span><span class="comments-link"><a href="https://systemisbusy.info/blog/2019/01/09/%e7%bc%96%e5%86%99%e5%85%8d%e6%b3%a8%e5%86%8ccom%e7%bb%84%e4%bb%b6%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf/#respond">Leave a comment<span class="screen-reader-text"> on 编写免注册COM组件的正确姿势</span></a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-## -->

<article id="post-123" class="post-123 post type-post status-publish format-standard hentry category-uncategorized">
	
	<header class="entry-header">
		<h2 class="entry-title"><a href="https://systemisbusy.info/blog/2018/12/26/%e6%9c%ac%e7%ab%99%e7%8e%b0%e5%b7%b2%e6%94%af%e6%8c%81hsts-preload/" rel="bookmark">本站现已支持HSTS Preload</a></h2>	</header><!-- .entry-header -->

	<div class="entry-content">
		<p>本站现已支持HSTS Preload，且已经在<a href="https://hstspreload.org/">https://hstspreload.org/</a>提交了preload审核。<br />
申请的时候发现了nginx需要改一下配置</p>
<pre><code class="">-add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
+add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
</code></pre>
<p>之前写的也订正了。</p>
<p>还有站点的首页从nginx示例页稍微改了一下，我真的不会HTML/CSS/JavaScript，所以首页看起来非常lowb。<br />
就这样。</p>
	</div><!-- .entry-content -->

	
	<footer class="entry-footer">
		<span class="posted-on"><span class="screen-reader-text">Posted on </span><a href="https://systemisbusy.info/blog/2018/12/26/%e6%9c%ac%e7%ab%99%e7%8e%b0%e5%b7%b2%e6%94%af%e6%8c%81hsts-preload/" rel="bookmark"><time class="entry-date published updated" datetime="2018-12-26T18:05:09+00:00">December 26, 2018</time></a></span><span class="comments-link"><a href="https://systemisbusy.info/blog/2018/12/26/%e6%9c%ac%e7%ab%99%e7%8e%b0%e5%b7%b2%e6%94%af%e6%8c%81hsts-preload/#respond">Leave a comment<span class="screen-reader-text"> on 本站现已支持HSTS Preload</span></a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-## -->

<article id="post-112" class="post-112 post type-post status-publish format-standard hentry category-uncategorized">
	
	<header class="entry-header">
		<h2 class="entry-title"><a href="https://systemisbusy.info/blog/2018/12/25/libstdc%e7%9a%84stdregex%e7%9a%84%e4%b8%80%e4%b8%aa%e5%9d%91/" rel="bookmark">libstdc++的std::regex的一个坑</a></h2>	</header><!-- .entry-header -->

	<div class="entry-content">
		<p>公司用Electron做的项目有个需求，前端的JS代码会把一张图片转成dataURL的格式传给cpp写的库，cpp把dataURL中的二进制数据提取出来通过自己的协议发给服务器。<br />
用dataURL可以把文件的内容嵌入到URL字符串中。比如这段字符串复制到浏览器地址栏然后按回车，就可以看到一张红色的GIF图片。</p>
<pre><code class="">data:image/gif;base64,R0lGODlhZABkAJEAAAAAAP////8AAP///yH5BAEAAAMALAAAAABkAGQAAAJzlI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+DwwKh8Si8YhMKpfMpvMJjUqn1Kr1is1qt9yu9wsOi8fksvmMTqvX7Lb7DY/L5/S6/Y7P6/f8vv8PGCg4SFhoeIiYqLjI2Oj4CGlYAAA7
</code></pre>
<p>用DataURL的好处是较小的文件可以直接嵌入到HTML中。如果这个文件在网站中出现的次数很少，直接用dataURL就可以不用单独管理这个文件了。</p>
<p>所以就有个需求，判断给定的字符串是不是dataURL的类型。我想当然地就用了<code>std::regex</code>来判断字符串是不是dataURL，之后用<code>std::regex_search</code>来提取URL包含的MIME类型和包含的数据。写了这么一个正则表达式：</p>
<pre><code class="">data:([a-zA-Z0-9/\+\-\.]*)(;(base64))?,(\S*)
</code></pre>
<p>当时没考虑到传过来的dataURL可能会很长，大小可能会有几个MB。之后QA说程序在linux下崩溃了，我挂上调试器按照同样的步骤重现了崩溃之后，看到了这么一个调用栈：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/DvPMf3rVAAEmCKV.jpg" alt="" /><br />
很明显regex_search在提取字符串的时候把调用栈弄爆了。查了libstdc++的std::regex里面的实现是用递归的，难怪容易爆栈。<br />
<a href="https://www.zhihu.com/question/23070203/answer/84248248">https://www.zhihu.com/question/23070203/answer/84248248</a><br />
改成只用regex解析文件头来判断就不崩溃了，dataURL里面包含的数据和URL头部的分界是个逗号，用第一个逗号字符出现的位置来分割应该没什么问题。</p>
<p>虽然程序崩了但是还是要膜这位实现出正则表达式引擎的Googler……</p>
<p>还有Visual Studio的linux调试器是个好东西。。。</p>
	</div><!-- .entry-content -->

	
	<footer class="entry-footer">
		<span class="posted-on"><span class="screen-reader-text">Posted on </span><a href="https://systemisbusy.info/blog/2018/12/25/libstdc%e7%9a%84stdregex%e7%9a%84%e4%b8%80%e4%b8%aa%e5%9d%91/" rel="bookmark"><time class="entry-date published" datetime="2018-12-25T18:50:51+00:00">December 25, 2018</time><time class="updated" datetime="2018-12-25T19:14:45+00:00">December 25, 2018</time></a></span><span class="comments-link"><a href="https://systemisbusy.info/blog/2018/12/25/libstdc%e7%9a%84stdregex%e7%9a%84%e4%b8%80%e4%b8%aa%e5%9d%91/#respond">Leave a comment<span class="screen-reader-text"> on libstdc++的std::regex的一个坑</span></a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-## -->

<article id="post-30" class="post-30 post type-post status-publish format-standard hentry category-uncategorized">
	
	<header class="entry-header">
		<h2 class="entry-title"><a href="https://systemisbusy.info/blog/2018/12/23/%e5%9c%a8debian-9%e7%8e%af%e5%a2%83%e4%b8%8b%e9%85%8d%e7%bd%ae%e5%9f%ba%e4%ba%8elnmp%e7%9a%84wordpress%e5%8d%9a%e5%ae%a2/" rel="bookmark">在Debian 9环境下配置基于LNMP的WordPress博客</a></h2>	</header><!-- .entry-header -->

	<div class="entry-content">
		<p>这其实是10月份写的文章。原来的blog在DigitalOcean上，因为ping实在是太高了，SSH和传文件很不爽，所以换了一家VPS服务商。新的VPS用的Linux发行版是openSUSE也不是Debian了。但是配置过程还是大同小异的。</p>
<p>因为URI改了，所以原来的文章没法迁移到这（你这懒癌晚期患者真的写过什么blog文章吗？），改备份的SQL真是改到吐血。好在原来的markdown还在，所以重新导入一下就可以。然后在文章里面补充了一些新问题的解决办法。</p>
<h2>==========原文==========</h2>
<p>鸽了一个月，总算把博客用wordpress搭起来了。把折腾部署网站的过程记下来，做个备忘。</p>
<p>网站用的是nginx服务器，OS是debian9，虽然说有懒人版的lnmp脚本，但是我把手动部署的过程走了一遍。<br />
搭建的过程主要参考了以下文章：<br />
<a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-nginx-on-ubuntu-14-04">https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-nginx-on-ubuntu-14-04</a></p>
<h2>新建一个带 sudo 权限的用户</h2>
<p>以root身份登录服务器，新建一个带sudo权限的用户，然后切换到该用户。</p>
<pre><code class="">adduser demo
usermod -a -G sudo demo
su demo
</code></pre>
<h2>安装PHP nginx MySQL</h2>
<p>安装之前先更新下服务器预装的软件包。然后安装环境。</p>
<pre><code class="language-bash ">sudo apt-get update &amp;&amp; apt-get dist-upgrade
</code></pre>
<p>首先安装以下软件包：<br />
nginx mariadb-server php php-gd php-mysql php-fpm php-ssh2</p>
<ul>
<li>php-fpm: php-fastcgi的一个实现。</li>
<li>php-gd: 为php语言添加处理图像数据的支持。</li>
<li>php-ssh2: 使得wordpress能通过ssh方式访问本地服务器。</li>
</ul>
<p>运行命令 <code>sudo apt-get -t stretch-backports install nginx php php-gd php-mysql php-fpm php-ssh2 mariadb-server</code> 来安装。</p>
<p>如果提示找不到stretch-backports仓库，在/etc/apt/sources.list文件中添加以下两行：</p>
<pre><code class="">deb http://http.us.debian.org/debian/ stretch-backports main contrib non-free
deb-src http://http.us.debian.org/debian stretch-backports main contrib non-free
</code></pre>
<p>然后 <code>sudo apt-get update</code> 刷新一下就可以安装了。</p>
<p>apt-get 会顺带把Apache(软件包名字叫apache2)也安装上，这里我们不用Apache做服务器。由于先安装了nginx并启动了服务，Apache安装成功之后它的服务也会启动失败。因此先输入命令<code>sudo systemctl disable apache2.service</code>把Apache服务关掉。</p>
<h2>配置全站https</h2>
<p>安装完nginx，在浏览器中输入http://&lt;你的VPS的IP>/ 应该能看到nginx的欢迎画面。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/nginx-ok.png" alt="" /></p>
<p>为了让网站的内容不会被运营商和功夫网视奸，进而水表不保。我们先把网站弄上https，并且让网站的SSL安全等级达到SSLlabs网站的A+评价。</p>
<h3>获取给域名颁发的SSL证书</h3>
<p>这里选择LetsEncrypt作为网站SSL证书的颁发者。首先在DNS控制台里把拥有的域名指向我们的服务器：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/domain.png" alt="" /></p>
<p>安装Certbot帮助我们自动签发LetsEncrypt证书，输入命令：</p>
<pre><code class="language-bash ">sudo apt-get install python-certbot-nginx -t stretch-backports
</code></pre>
<p>输入配置Certbot自动签发的命令：</p>
<pre><code class="language-bash ">sudo certbot certonly --authenticator standalone --pre-hook "systemctl stop nginx.service" --post-hook "systemctl start nginx.service"
</code></pre>
<p>配置期间会让你输入以下信息：<br />
 &#8211; 用于签发证书的邮箱<br />
 &#8211; 要签发证书的域名</p>
<p>输入后一路按回车，SSL证书应该就签发好了。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/certbot-config.png" alt="" /></p>
<h4>检验Certbot是否能自动续签证书</h4>
<p>见 <a href="https://certbot.eff.org/docs/using.html#automated-renewals">https://certbot.eff.org/docs/using.html#automated-renewals</a> 。</p>
<p>具体方法是输入命令<code>systemctl list-timers</code> 可以看到有个计时器名叫<code>certbot.timer</code>，证明自动续签定时器是有效的。<br />
要检验证书续签是否有效，输入命令：</p>
<pre><code class="language-bash ">sudo certbot renew --dry-run
</code></pre>
<p><img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/certbot-renew-timer.png" alt="" /></p>
<h3>配置nginx服务器应用https</h3>
<p>打开文件 /etc/nginx/sites-enabled/default，添加或把现有配置修改为以下内容：</p>
<pre><code class=""># 监听80端口，把所有的http请求通过返回301值重定向到https上
server {
    listen 80 default_server;              # IPv4
    listen [::]:80 default_server;         # IPv6
    server_name http_redirect;             # 服务器配置名
    return 301 https://$host$request_uri;  # http请求全都通过301重定向到同名的https URL上
}
# 监听443端口，提供https服务
server {
    listen 443 ssl;                        # 监听443端口，且开启ssl
    listen [::]:443 ssl;                   # v6

    # 使用的SSL 证书，这里用之前letsEncrypt签发证书存放的位置
    ssl_certificate /etc/letsencrypt/live/&lt;your domain here&gt;/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/&lt;your domain here&gt;/privkey.pem;

    # 复用SSL连接
    ssl_session_cache          shared:SSL:1m;
    ssl_session_timeout        5m;

    # SSL加密方式这里用的是nginx的默认设置
    ssl_ciphers                HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers  on;

    ssl_protocols TLSv1.2;                 # 只支持TLS v1.2协议

    # 访问日志
    access_log  /var/log/nginx/host.access.log;
    error_log   /var/log/nginx/host.error.log;

    # 开启 HSTS 支持
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    server_name https_web;

    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }

    location = /robots.txt {
        allow all;
        log_not_found off;
        access_log off;
    }

    root /var/www/html;

    # Add index.php to the list if you are using PHP
    index index.html index.htm index.nginx-debian.html;

    location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        try_files $uri $uri/ =404;
    }
}
</code></pre>
<p>要达到A+级评分，还需要一个强度较高的用于DH密钥交换的key。否则评价会限制在B级上。</p>
<p>首先输入命令 <code>openssl dhparam -out /etc/nginx/dhparam.pem 2048</code> 生成一个新密钥。<br />
然后打开<code>/etc/nginx/nginx.conf</code>，在http栏添加配置：</p>
<pre><code class="">ssl_dhparam dhparam.pem;
</code></pre>
<p>以上步骤都完成之后，输入<code>systemctl restart nginx.service</code> 重启nginx服务。<br />
这时在浏览器里面输入域名，应该能正确跳转到https连接，并且证书是有效的，在SSLlabs网站上检测也能拿到A+的评价。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/https-ok.png" alt="" /><br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/ssl-a.png" alt="" /></p>
<h2>配置MySQL(MariaDB)服务器</h2>
<p>输入命令<code>mysql -u root -p</code>以root用户身份登录MariaDB服务器，提示输入密码时输入root账户的密码，登录到MariaDB数据库。</p>
<p>我们现在要为WordPress新建一个数据库，然后建立一个新用户供WordPress程序使用。该用户只能读写WordPress数据库中的内容。</p>
<p>为了保证数据库的安全，先移除掉MariaDB安装后的一些默认设置。<br />
运行脚本：</p>
<pre><code class="">mysql_secure_installation
</code></pre>
<p>脚本会提示你重新设置root密码，移除掉匿名用户，禁止root用户远程登录MariaDB服务器，移除MariaDB安装时附带的测试数据库。</p>
<p>之后配置数据库。<br />
输入以下命令：</p>
<pre><code class="">create database wordpress;
create user wp@localhost identified by 'dontusethispassword'; -- 只允许本地登录（不要用这个密码！）
grant all privileges on wordpress.* to wp@localhost; -- 给用户 wp 对数据库 wordpress 所有的操作权限 
flush privileges; -- 刷新权限配置
</code></pre>
<p>配置完成，输入<code>\q</code>退出MySQL控制台。</p>
<h2>配置WordPress网站并初始化博客网站</h2>
<h3>下载WordPress最新版本</h3>
<p>从WordPress 官方网站下载最新版本的Wordpress压缩包，放置在本地目录并解压：</p>
<pre><code class="">cd ~
curl -O https://wordpress.org/latest.tar.gz
tar xzvf latest.tar.gz
</code></pre>
<h3>设置WordPress的<code>wp-config.php</code></h3>
<p>进入解压出来的WordPress目录，将示例配置文件<code>wp-config-sample.php</code>复制一份，命名为<code>wp-config.php</code>。</p>
<pre><code class="">cd wordpress
cp wp-config-sample.php wp-config.php
</code></pre>
<p>打开<code>wp-config.php</code>，将以下内容</p>
<pre><code class="">// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define('DB_NAME', 'database_name_here');

/** MySQL database username */
define('DB_USER', 'username_here');

/** MySQL database password */
define('DB_PASSWORD', 'password_here');
</code></pre>
<p>修改为：</p>
<pre><code class="">// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define('DB_NAME', 'wordpress');      // WordPress要使用的数据库名

/** MySQL database username */
define('DB_USER', 'wp');                      // MySQL数据库用户名

/** MySQL database password */
define('DB_PASSWORD', 'dontusethispassword'); // 之前建立的用户 wp 的密码。
</code></pre>
<p>从 <a href="https://api.wordpress.org/secret-key/1.1/salt/">https://api.wordpress.org/secret-key/1.1/salt/</a> 获取存储用户验证信息时要加的盐（不要原样复制这里的数据！）：</p>
<pre><code class="">define('AUTH_KEY',         '/ (+4E5i---qv ^ql_!6SYfy1 &lt;DO_NOT_COPY_VALUES_HERE&gt; S w!GFli/}0mGA-5X!H5MgophTWq8*$#-s|Nt&lt;O');
define('SECURE_AUTH_KEY',  'zyJ0+.lntK(pmoLz}{&amp;2r4hIZ &lt;DO_NOT_COPY_VALUES_HERE&gt; PSU+$;OwVmZ-M-~FMOCOsCcqui9Q^mhUG*V]F=M');
define('LOGGED_IN_KEY',    'FqO}:DqL&amp;_(YEh(G;90u_?]9h &lt;DO_NOT_COPY_VALUES_HERE&gt; .$)&gt;:G`i.%(Imechhw@]lHuaF3Mvqt&lt;q%NhM&gt;Kj');
define('NONCE_KEY',        'ENG`i~-XP}o|-qe]tks~FVB@5 &lt;DO_NOT_COPY_VALUES_HERE&gt; ~;p;SVy6A)kNEqZ9Mw(Rgm`w={N&amp;&gt;*KXK)eh_|;');
define('AUTH_SALT',        'xgMO]-tb^*YZhRG(sU0N{u2Wi &lt;DO_NOT_COPY_VALUES_HERE&gt; 9$0B0/SpB}|C6(,+deb];=RYb=-R!d$_&amp; 9qHDr');
define('SECURE_AUTH_SALT', ')-/GgH`&gt;p6SU2bx*)nV?=}+3c &lt;DO_NOT_COPY_VALUES_HERE&gt; 2L6#8Pqn0@-bRm&amp;D}T+2L.+nA638|y+|:`zF,4T');
define('LOGGED_IN_SALT',   '+Y|Pm`ExaNg|KoU&lt;h`D,Kaw0u &lt;DO_NOT_COPY_VALUES_HERE&gt; b.QEa-=[g*&lt;E/$EIBcOa^O|eNQFmnsB+D-w?:uW');
define('NONCE_SALT',       '_/4.-?-QB[)p0&lt;U#M{MCqCum* &lt;DO_NOT_COPY_VALUES_HERE&gt; d!$bs4v%J:imVE^WRaLyZ 51m|&amp;-ckqaV=dzvM_');
</code></pre>
<p>替换掉<code>wp-config.php</code>中原有的内容：</p>
<pre><code class="">define('AUTH_KEY',         'put your unique phrase here');
define('SECURE_AUTH_KEY',  'put your unique phrase here');
define('LOGGED_IN_KEY',    'put your unique phrase here');
define('NONCE_KEY',        'put your unique phrase here');
define('AUTH_SALT',        'put your unique phrase here');
define('SECURE_AUTH_SALT', 'put your unique phrase here');
define('LOGGED_IN_SALT',   'put your unique phrase here');
define('NONCE_SALT',       'put your unique phrase here');
</code></pre>
<p>保存并退出编辑器。</p>
<h3>复制WordPress文件至网站根目录，配置目录权限</h3>
<p>复制WordPress至网站根目录，然后进入该目录。</p>
<pre><code class="">sudo rsync -avP ~/wordpress/ /var/www/wordpress
cd /var/www/wordpress
</code></pre>
<p>运行nginx进程的用户所在的组有www-data，让nginx能读写WordPress所在的目录：</p>
<pre><code class="">sudo chown -R demo:www-data /var/www/wordpress/*
</code></pre>
<p>新建<code>wp-content/uploads</code>目录，然后设置权限，使得我们在网页端能上传文件。</p>
<pre><code class="">mkdir wp-content/uploads
sudo chown -R :www-data ./wp-content/uploads
</code></pre>
<h3>配置nginx</h3>
<p>打开<code>/etc/nginx/sites-enabled/default</code>文件，修改配置：</p>
<pre><code class="">    root /var/www/wordpress;
    index index.php index.html index.htm index.nginx-debian.html;

    location / {
        try_files $uri $uri/ =404;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
        include fastcgi_params;
    }

    location ~ /\.ht {
        deny all;
    }
</code></pre>
<p>最终修改完成的配置文件如下：</p>
<pre><code class="">server {
    listen 80 default_server;              # IPv4
    listen [::]:80 default_server;         # IPv6
    server_name http_redirect;             # 服务器配置名
    return 301 https://$host$request_uri;  # http请求全都通过301重定向到同名的https URL上
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;

    # SSL configuration
    #
    # listen 443 ssl default_server;
    # listen [::]:443 ssl default_server;
    #
    # Note: You should disable gzip for SSL traffic.
    # See: https://bugs.debian.org/773332
    #
    # Read up on ssl_ciphers to ensure a secure configuration.
    # See: https://bugs.debian.org/765782
    #
    # Self signed certs generated by the ssl-cert package
    # Don't use them in a production server!
    #
    # include snippets/snakeoil.conf;
    # 使用的SSL 证书，这里用之前letsEncrypt签发证书存放的位置
    ssl_certificate /etc/letsencrypt/live/&lt;your domain here&gt;/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/&lt;your domain here&gt;/privkey.pem;
    # 复用SSL连接
    ssl_session_cache          shared:SSL:1m;
    ssl_session_timeout        5m;
    # SSL加密方式这里用的是nginx的默认设置
    ssl_ciphers                HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers  on;

    ssl_protocols TLSv1.2;                 # 只支持TLS v1.2协议

    # 访问日志
    access_log  /var/log/nginx/host.access.log;
    error_log   /var/log/nginx/host.error.log;

    # 添加 HSTS 支持
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    server_name https_web;

    root /var/www/wordpress;

    # Add index.php to the list if you are using PHP
    index index.php index.html index.htm index.nginx-debian.html;

    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }

    location = /robots.txt {
        allow all;
        log_not_found off;
        access_log off;
    }

    location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        try_files $uri $uri/ =404;
    }

    # pass PHP scripts to FastCGI serve
    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        # With php-fpm (or other unix sockets):
        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
        include fastcgi_params;
    }

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    location ~ /\.ht {
        deny all;
    }
}

</code></pre>
<p>重启nginx和php-fpm服务：</p>
<pre><code class="">sudo systemctl restart nginx.service
sudo systemctl restart php7.0-fpm.service
</code></pre>
<h3>访问网站完成WordPress配置</h3>
<p>这时在浏览器地址里面输入你的域名，应该能显示WordPress的安装页了。输入站点名、用户名、密码、邮箱，wordpress会自动帮你配置好其余的东西。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/wordpress-ok.png" alt="" /><br />
然后WordPress会提示你登录，登录后进入WordPress管理员页面。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/wordpress-install-ok.png" alt="" /><br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/wordpress-admin-page.png" alt="" /><br />
这时WordPress的配置就完成了。</p>
<h3>排错</h3>
<p>遇到网页打不开的情况时，可以打开<code>wp-config.php</code>，然后打开调试开关：</p>
<pre><code class="">define('WP_DEBUG', true);
define('WP_DEBUGLOG', true);
</code></pre>
<p>之后可以在<code>wp-content/debug.log</code>找到调试日志。</p>
<p>碰到css加载不出来之类的问题，去翻<code>/var/log/nginx/host.access.log</code>和<code>/var/log/nginx/host.access.log</code>这两个文件。</p>
<h2>后续配置</h2>
<p>博客启动后的后续配置目前碰到了一些坑，这里记录已经遇到的问题和解决办法。</p>
<h3>在WordPress管理员页面不能安装插件，需要FTP/SSH用户凭据</h3>
<p>如图，安装插件时WordPress提示需要FTP或者SSH凭据。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/require-ftp-credential.png" alt="" /></p>
<p>解决方法是在<code>wp-config.php</code>中加上：</p>
<pre><code class="">define('FS_METHOD','direct');
</code></pre>
<p>然后运行命令，给组赋予写的权限</p>
<pre><code class="">sudo chmod g+w &lt;your wordpress dir&gt;/wp-content/* -R
</code></pre>
<p>即可解决该问题。</p>
<h3>我想更改管理员邮箱，但是收不到确认信件</h3>
<p>原因可能是主机商把mail()禁用了。检验方法是进入WordPress登录页面，点忘记密码，然后输入你的管理员邮箱，点获取新密码。如果出现以下提示，提示mail()函数被主机商禁用，那么就是这种情况。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/mail-disabled.png" alt="" /></p>
<p>解决的办法除了有联系主机商提供支持之外，还可以使用第三方的SMTP服务。这里以gmail为例：</p>
<ul>
<li>安装 WP Mail SMTP by WPForms 插件。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/WP-Mail-SMTP-by-WPForms.png" alt="" /></p>
</li>
<li>
<p>在插件设定页中指定你要发邮件的gmail邮箱：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/WP-Mail-SMTP-setting-1.png" alt="" /></p>
</li>
<li>登录 <a href="https://console.developers.google.com/flows/enableapi?apiid=gmail&amp;pli=1">https://console.developers.google.com/flows/enableapi?apiid=gmail&amp;pli=1</a>
<ul>
<li>先选择一个Project，没有则新建一个。</li>
<li>在Add credentials to your project页面配置如下：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/gmail-credential.png" alt="" /></li>
<li>选择新建一个OAuth client ID：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/gmail-credential-new.png" alt="" /><br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/gmail-credential-ok.png" alt="" /></li>
<li>把生成出来的凭据填进插件设置页对应的输入框中：<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/WP-Mail-SMTP-by-WPForms-ok.png" alt="" /></li>
<li>点保存设置，然后点击Allow plugin to send emails using your Google account，授权插件使用该gmail邮箱发送邮件。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/gmail-credential-auth.png" alt="" /></li>
<li>最后可以进入Email Test页发送邮件，测试发送服务是否已经生效。生效可能需要一段时间。<br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/WP-Mail-SMTP-send-test.png" alt="" /><br />
<img src="https://systemisbusy.info/blog/wp-content/uploads/2018/12/WP-Mail-SMTP-send-ok.png" alt="" /></li>
</ul>
</li>
</ul>
<h3>我更改了WordPress的Permalink设置，然后博客上所有的链接都404了</h3>
<p>解决方法是在<code>/etc/nginx/sites-enabled/default</code>中的https服务器配置中添加以下配置（仅适用于把WordPress作为网站根目录的情况）：</p>
<pre><code class="">    if (!-e $request_filename) {
        rewrite ^.*$ /index.php last;
    }
</code></pre>
<h3>WordPress上传不了大小超过2MB的东西</h3>
<p>要更改PHP所允许的最大上传大小和nginx能接受的请求包的最大的大小。</p>
<ul>
<li>首先找到PHP加载的配置文件的位置，输入命令<code>php -i | grep "Loaded Configuration File"</code>。</li>
<li>这里得到<code>php.ini</code>的位置在 <code>/etc/php/7.0/cli/php.ini</code>。</li>
<li>修改 <code>php.ini</code> 中的配置项<code>upload_max_filesize</code>和<code>post_max_size</code>至想要的大小数值。这里设成64MB。</li>
</ul>
<pre><code class="">  post_max_size = 64M
  upload_max_filesize = 64M
</code></pre>
<ul>
<li>保存<code>php.ini</code>后，重启<code>php7.0-fpm.service</code>。</li>
</ul>
<pre><code class="">  systemctl restart php7.0-fpm.serivice
</code></pre>
<ul>
<li>如果还是不行，那还需要修改nginx的配置。修改<code>/etc/nginx/nginx.conf</code>，在http栏加上配置：</li>
</ul>
<pre><code class="">  client_max_body_size 64M;
</code></pre>
<ul>
<li>之后重启服务<code>nginx.service</code>。</li>
</ul>
<h2>参考资料</h2>
<p>配置LNMP/wordpress: <a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-nginx-on-ubuntu-14-04">https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-nginx-on-ubuntu-14-04</a></p>
<p>签发Let&#8217;s Encrypt证书: <a href="https://certbot.eff.org/lets-encrypt/debianstretch-nginx">https://certbot.eff.org/lets-encrypt/debianstretch-nginx</a></p>
<p>提升SSLlabs评价分数: <a href="https://michael.lustfield.net/nginx/getting-a-perfect-ssl-labs-score">https://michael.lustfield.net/nginx/getting-a-perfect-ssl-labs-score</a></p>
<p>安装插件: <a href="https://www.digitalocean.com/community/questions/wordpress-asking-for-ftp-credentials">https://www.digitalocean.com/community/questions/wordpress-asking-for-ftp-credentials</a></p>
<p>Permalink设置：<a href="https://www.digitalocean.com/community/questions/404-when-using-pretty-permalinks-on-new-wordpress-site-on-lemp-nginx">https://www.digitalocean.com/community/questions/404-when-using-pretty-permalinks-on-new-wordpress-site-on-lemp-nginx</a></p>
	</div><!-- .entry-content -->

	
	<footer class="entry-footer">
		<span class="posted-on"><span class="screen-reader-text">Posted on </span><a href="https://systemisbusy.info/blog/2018/12/23/%e5%9c%a8debian-9%e7%8e%af%e5%a2%83%e4%b8%8b%e9%85%8d%e7%bd%ae%e5%9f%ba%e4%ba%8elnmp%e7%9a%84wordpress%e5%8d%9a%e5%ae%a2/" rel="bookmark"><time class="entry-date published" datetime="2018-12-23T20:05:26+00:00">December 23, 2018</time><time class="updated" datetime="2018-12-26T18:05:58+00:00">December 26, 2018</time></a></span><span class="comments-link"><a href="https://systemisbusy.info/blog/2018/12/23/%e5%9c%a8debian-9%e7%8e%af%e5%a2%83%e4%b8%8b%e9%85%8d%e7%bd%ae%e5%9f%ba%e4%ba%8elnmp%e7%9a%84wordpress%e5%8d%9a%e5%ae%a2/#respond">Leave a comment<span class="screen-reader-text"> on 在Debian 9环境下配置基于LNMP的WordPress博客</span></a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-## -->

		</main><!-- .site-main -->
	</section><!-- .content-area -->


	</div><!-- .site-content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
									<a href="https://wordpress.org/" class="imprint">
				Proudly powered by WordPress			</a>
		</div><!-- .site-info -->
	</footer><!-- .site-footer -->

</div><!-- .site -->

<script type='text/javascript' src='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/js/skip-link-focus-fix.js?ver=20141010'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var screenReaderText = {"expand":"<span class=\"screen-reader-text\">expand child menu<\/span>","collapse":"<span class=\"screen-reader-text\">collapse child menu<\/span>"};
/* ]]> */
</script>
<script type='text/javascript' src='https://systemisbusy.info/blog/wp-content/themes/twentyfifteen/js/functions.js?ver=20150330'></script>
<script type='text/javascript' src='https://systemisbusy.info/blog/wp-includes/js/wp-embed.min.js?ver=5.2.3'></script>

</body>
</html>
